// FILE: lib/app/controllers/game_controller.dart
import 'dart:math';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/models/app_message.dart';
import '../../domain/models/player.dart';
import '../../domain/models/skill.dart';
import '../../domain/models/team.dart';
import '../../domain/models/league.dart';
import '../../domain/models/economy.dart';

import '../../domain/models/played_match.dart';
import '../../domain/models/fixture.dart';
import '../../domain/models/league_table.dart';

import '../../data/services/training_service.dart';
import '../../data/services/match_service.dart';
import '../../data/services/economy_service.dart';

import '../../features/match/models/match_moment.dart';
import '../../features/match/services/match_moments_engine.dart';
import '../providers/providers.dart';
import '../state/game_state.dart';

// Notifications & message templates
import '../../messages/general_messages.dart';
import '../../messages/economy_messages.dart';
import '../../messages/match_messages.dart';
import '../../messages/skill_messages.dart';
import '../../messages/casino_messages.dart';
import '../../domain/models/skills_catalog.dart';

---
class GameController extends Notifier<GameState> {
  late final _training = TrainingService();
  late final _match = MatchService();
  late final _eco = EconomyService();
  final _rng = Random();
  late final _moments = MatchMomentsEngine();

  @override
  GameState build() => _initialState();

  GameState _initialState() {
    // Seed players
    final p = _createInitialPlayer();
    final q = _createInitialPlayer().copyWith(
      name: "Joao Costa",
      role: PlayerRole.striker,
    );
    final my = Team(
      id: "t1",
      name: "HashStorm FC",
      squad: [p, q],
      morale: 0.75,
    );

    final lg = const League(
      id: "pt2",
      name: "Second Division",
      multiplier: 1.00,
    );
    final eco = const Economy(cash: 10000, weeklyIncome: 800, weeklyCosts: 500);

    // Generate AI teams
    final aiTeams = <String>[
      "Lisbon United",
      "Coimbra City",
      "Porto Athletic",
      "Braga Royals",
      "Faro Mariners",
      "Setubal Rangers",
      "Aveiro Town",
      "Leiria Eagles",
    ];

    // Initial opponent: first AI team
    final opponent = _generateAIOpponent(aiTeams.first);

    // Create fixtures: my team plays each AI team once, one per week
    final fixtures = <Fixture>[];
    for (var i = 0; i < aiTeams.length; i++) {
      fixtures.add(
        Fixture(week: i + 1, homeTeam: my.name, awayTeam: aiTeams[i]),
      );
    }

    // Seed empty table with all teams
    var table = const LeagueTable({});
    table = table.upsertTeam(my.name);
    for (final t in aiTeams) {
      table = table.upsertTeam(t);
    }

    return GameState(
      myTeam: my,
      opponent: opponent,
      league: lg,
      economy: eco,
      week: 1,
      history: const [],
      fixtures: fixtures,
      table: table,
      aiTeams: aiTeams,
    );
  }

  Team _generateAIOpponent(String name) {
    // Local helpers -------------------------------------------------------------
    PlayerRole _findRole(List<String> hints) {
      for (final h in hints) {
        final hint = h.toLowerCase();
        for (final r in PlayerRole.values) {
          if (r.name.toLowerCase().contains(hint)) return r;
        }
      }
      return PlayerRole.values.first; // fallback
    }

    Map<String, Skill> _baseSkillsWithNoise() {
      final skills = <String, Skill>{};
      SkillsCatalog.all28Skills.forEach((id, base) {
        skills[id] = base.copyWith(
          level: 45 + _rng.nextInt(26), // 45..70
          currentXp: _rng.nextInt(30),
        );
      });
      return skills;
    }

    Player _mk(int idx, PlayerRole role) {
      return Player(
        id: "ai$idx",
        name: "AI-$idx",
        age: 18 + _rng.nextInt(15),
        role: role,
        skills: _baseSkillsWithNoise(),
        form: 0.6 + _rng.nextDouble() * 0.3,
        fatigue: 0.1 + _rng.nextDouble() * 0.3,
        reputation: 10 + _rng.nextDouble() * 15,
        sp: 0,
        consistency: 45 + _rng.nextInt(20).toDouble(),
        determination: 45 + _rng.nextInt(20).toDouble(),
        leadership: 40 + _rng.nextInt(25).toDouble(),
      );
    }
    // --------------------------------------------------------------------------

    // Target XI (4-4-2-ish)
    final templateRoles = <PlayerRole>[
      _findRole(['gk', 'goal']), // GK
      _findRole(['cb', 'def']), // CB
      _findRole(['cb', 'def']), // CB
      _findRole(['back', 'wing', 'def']), // LB/RB/WB
      _findRole(['back', 'wing', 'def']), // LB/RB/WB
      _findRole(['mid', 'cm']), // CM
      _findRole(['mid', 'cm']), // CM
      _findRole(['mid', 'cm']), // CM/Wide mid
      _findRole(['mid', 'cm']), // CM/Wide mid
      _findRole(['st', 'striker', 'forward']), // ST
      _findRole(['st', 'striker', 'forward']), // ST
    ];

    final squad = <Player>[];
    for (int i = 0; i < templateRoles.length; i++) {
      squad.add(_mk(i, templateRoles[i]));
    }
    squad.shuffle(_rng); // randomize order a bit

    return Team(
      id: "ai_${name.hashCode}",
      name: name,
      squad: squad, // exactly 11 with a GK guaranteed by hints
      morale: 0.6 + _rng.nextDouble() * 0.3,
    );
  }

  // =========================
  // PLAYER-CENTRIC UTILITIES
  // =========================

  String get _meId => state.myTeam.squad.first.id;

  Player get _me => state.myTeam.squad.firstWhere((p) => p.id == _meId);

  void _commitMe(Player updated) {
    final squad = [...state.myTeam.squad];
    final idx = squad.indexWhere((p) => p.id == updated.id);
    if (idx != -1) {
      squad[idx] = updated;
      state = state.copyWith(myTeam: state.myTeam.copyWith(squad: squad));
    }
  }

  /// Treino pessoal numa skill específica usando o novo sistema XP
  void selfTrain(String skillId) {
    final me0 = _me;

    // Usa o novo sistema de trainSkill com XP
    final trained = _training.trainSkill(me0, skillId, baseXp: 30);

    // Aplica fadiga e forma adicionais do treino manual
    final updatedPlayer = trained.copyWith(
      fatigue: (trained.fatigue + 0.05).clamp(0, 1),
      // Fadiga extra do treino manual
      form: (trained.form * 0.99).clamp(0, 1), // Pequeno ajuste na forma
    );

    _commitMe(updatedPlayer);

    // Notificação com skill name localizado
    final skill = updatedPlayer.skills[skillId];
    if (skill != null) {
      _notify(
        'Training',
        'Trained ${skill.id} - Level ${skill.level}' +
            (skill.queuedLevels > 0 ? ' (+${skill.queuedLevels} queued)' : ''),
      );
    }
  }

  /// Sessão de recuperação pessoal
  void recoverSelf() {
    final me0 = _me;
    final rested = me0.copyWith(
      fatigue: (me0.fatigue - 0.18).clamp(0, 1),
      form: (me0.form * 0.97 + 0.03).clamp(0, 1),
    );
    _commitMe(rested);
    _notify('Training', '${me0.name} completed a recovery session');
  }

  // =========================
  // TRAINING (legacy wrappers)
  // =========================

  /// [LEGACY] Treinar um jogador específico — mantém para compatibilidade.
  /// Se o playerId for o "eu", delega em selfTrain; caso contrário, ignora.
  void train(String playerId, String skillId) {
    if (playerId == _meId) {
      selfTrain(skillId);
      return;
    }
    // No-op para outros jogadores (não és treinador).
  }

  /// [LEGACY] Descansar a equipa toda — não faz sentido para player. Mapeado para recoverSelf().
  void restAll() {
    recoverSelf();
  }

  // =========================
  // ECONOMY
  // =========================

  void _setEconomy(Economy next) {
    state = state.copyWith(economy: next);
  }

  /// Records a manual expense and updates all spend metrics consistently.
  void addExpense(int amount) {
    if (amount <= 0) return;
    final next = _eco.recordExpense(state.economy, amount);
    _setEconomy(next);
  }

  /// Records a manual earning and updates all earn metrics consistently.
  void addEarning(int amount) {
    if (amount <= 0) return;
    final next = _eco.recordEarning(state.economy, amount);
    _setEconomy(next);
  }

  /// Apply weekly finances, roll to next week, and (if fixtures exist) prepare next opponent.
  /// Clears `spentWeek` and aggregates weekly income/costs into season/lifetime metrics.
  /// Also emits notifications (general + economy summary).
  void endOfWeekEconomy() {
    // 1) Aggregate this week's scheduled flows into cumulative metrics
    final e0 = state.economy;
    final earned = e0.weeklyIncome;
    final spent = e0.weeklyCosts;

    final eAggregated = e0.copyWith(
      earnedSeason: e0.earnedSeason + earned,
      earnedAllTime: e0.earnedAllTime + earned,
      spentSeason: e0.spentSeason + spent,
      spentAllTime: e0.spentAllTime + spent,
    );

    // 2) Apply weekly delta to cash (income - costs)
    final applied = _eco.applyWeekly(eAggregated);
    final delta = earned - spent;

    // 3) New week: clear manual weekly spent
    final economyNextWeek = applied.copyWith(spentWeek: 0);

    // 4) Advance calendar
    final nextWeek = state.week + 1;

    // 5) Optional: set next opponent from fixtures (keeps current if none)
    var nextOpponent = state.opponent;
    try {
      final nextFixture = state.fixtures.firstWhere(
        (f) => f.week == nextWeek,
        orElse: () => const Fixture(week: -1, homeTeam: '', awayTeam: ''),
      );
      if (nextFixture.week > 0) {
        nextOpponent = _generateAIOpponent(nextFixture.awayTeam);
      }
    } catch (_) {
      // Keep current opponent if anything goes wrong
    }

    // 6) Commit state
    state = state.copyWith(
      week: nextWeek,
      economy: economyNextWeek,
      opponent: nextOpponent,
    );

    // 7) Notify (general + economy summary)
    _notify('General', GeneralMessages.weekEnded(nextWeek - 1));
    _notify(
      'Economy',
      EconomyMessages.weekSummary(earned, spent, delta, economyNextWeek.cash),
    );
  }

  /// Place a casino wager. Updates cash and tracks spent/earned metrics accordingly.
  /// Emits a notification about win/loss.
  void casinoWager(int amount) {
    final e0 = state.economy;

    // Sanitize amount
    final wager = amount.clamp(0, e0.cash);
    if (wager == 0) return;

    final beforeCash = e0.cash;
    final afterEconomy = _eco.casino(e0, wager);
    final afterCash = afterEconomy.cash;

    final delta = afterCash - beforeCash;

    Economy withStats;
    if (delta >= 0) {
      // Win: add to earnings
      withStats = afterEconomy.copyWith(
        earnedSeason: e0.earnedSeason + delta,
        earnedAllTime: e0.earnedAllTime + delta,
      );
      state = state.copyWith(economy: withStats);
      _notify('Casino', CasinoMessages.win(delta, withStats.cash));
    } else {
      // Loss: add to expenses
      final loss = -delta;
      withStats = afterEconomy.copyWith(
        spentWeek: e0.spentWeek + loss,
        spentSeason: e0.spentSeason + loss,
        spentAllTime: e0.spentAllTime + loss,
      );
      state = state.copyWith(economy: withStats);
      _notify('Casino', CasinoMessages.loss(loss, withStats.cash));
    }
  }

  /// Convenience: all-in using current cash.
  void casinoAllIn() {
    casinoWager(state.economy.cash);
  }

  /// Same as casinoWager but returns (delta, win) for UI feedback.
  ({int delta, bool win}) casinoWagerWithResult(int amount) {
    final before = state.economy.cash;
    casinoWager(amount);
    final after = state.economy.cash;
    final delta = after - before;
    final win = delta > 0;
    return (delta: delta, win: win);
  }

  // =========================
  // MATCH / FIXTURES
  // =========================

  double _calculateRatingAux(PlayerStats? stats) {
    if (stats == null) return 6.0;

    // 6.0 base + contributos - penalizações
    final rating = 6.0
        + 1.2 * (stats.goals)
        + 0.6 * (stats.assists)
        - 0.3 * (stats.yellow)
        - 1.0 * (stats.red);

    return rating.clamp(4.0, 10.0);
  }

  void playMatch() {
    // Allow only one official match per week (based on fixtures)
    final fxIndex = state.fixtures.indexWhere((f) => f.week == state.week);
    if (fxIndex == -1) {
      // No fixture defined for this week; fallback to current opponent (friendly)
      final fullHome = _ensureXI(state.myTeam);
      final fullAway = _ensureXI(state.opponent);
      final sim = _moments.simulate(home: fullHome, away: fullAway);
      final homeGoals = sim.score.home;
      final awayGoals = sim.score.away;

      _playAndRecord(fullHome.name, fullAway.name);
      _notify('Match', MatchMessages.friendly(fullHome.name, fullAway.name));

      // SP: rating * multiplier(moments) — friendly still dá SP
      final myStats = sim.playerStats[_meId];
      final double rating = _calculateRatingAux(myStats);
      final momentsMult = (1.0 + (sim.moments.length * 0.05)).clamp(1.0, 2.0);
      final spGain = (rating * momentsMult).round().clamp(1, 20);

      // Minimal XP por match nas skills (progresso lento)
      final meAfterMinimalXp = _training.applyMinimalMatchXp(
        fullHome.squad.firstWhere((p) => p.id == _meId),
        perSkill: 2,
      ).copyWith(sp: fullHome.squad.firstWhere((p) => p.id == _meId).sp + spGain);

      // Atualiza squad (apenas eu mudo aqui)
      final newSquad = fullHome.squad.map((p) {
        if (p.id != _meId) return p;
        return meAfterMinimalXp.copyWith(
          form: (meAfterMinimalXp.form * 0.98 + (homeGoals > 0 ? 0.04 : 0.02)).clamp(0, 1),
          fatigue: (meAfterMinimalXp.fatigue + 0.15).clamp(0, 1),
        );
      }).toList();

      state = state.copyWith(
        myTeam: fullHome.copyWith(squad: newSquad),
        opponent: fullAway,
        lastMatchMoments: sim.moments,
        lastMatchScore: sim.score,
        lastMatchPlayerStats: sim.playerStats,
      );

      _notify('Skills', 'Earned $spGain SP from match performance!');
      return;
    }

    final fx = state.fixtures[fxIndex];
    if (fx.played) return;

    final oppName = fx.awayTeam;
    final ensuredOpp = state.opponent.name == oppName
        ? state.opponent
        : _generateAIOpponent(oppName);

    final fullHome = _ensureXI(state.myTeam);
    final fullAway = _ensureXI(ensuredOpp);

    final sim = _moments.simulate(home: fullHome, away: fullAway);

    final homeGoals = sim.score.home;
    final awayGoals = sim.score.away;

    // Reputação simples para lado da casa (mantém lógica existente)
    final homeRepDelta = homeGoals > awayGoals ? 0.5 : (homeGoals < awayGoals ? -0.5 : 0.1);

    // SP: rating * multiplier(moments)
    final myStats = sim.playerStats[_meId];
    final rating = (myStats?.rating ?? 6.0);
    final momentsMult = (1.0 + (sim.moments.length * 0.05)).clamp(1.0, 2.0);
    final int spGain = (rating * momentsMult).round().clamp(1, 20);

    // Minimal XP por match nas skills (progresso lento)
    final me0 = fullHome.squad.firstWhere((p) => p.id == _meId);
    final meAfterMinimalXp = _training.applyMinimalMatchXp(me0, perSkill: 2)
        .copyWith(sp: me0.sp + spGain);

    // Atualiza apenas o meu jogador com rep/form/fadiga + SP e XP mínimo
    final finalSquad = fullHome.squad.map((p) {
      if (p.id != _meId) return p;
      return meAfterMinimalXp.copyWith(
        reputation: (meAfterMinimalXp.reputation + homeRepDelta).clamp(0, 100),
        form: (meAfterMinimalXp.form * 0.98 + (homeGoals > 0 ? 0.04 : 0.02)).clamp(0, 1),
        fatigue: (meAfterMinimalXp.fatigue + 0.15).clamp(0, 1),
      );
    }).toList();

    // Record PlayedMatch
    final played = PlayedMatch(
      week: state.week,
      homeName: fullHome.name,
      awayName: fullAway.name,
      homeGoals: homeGoals,
      awayGoals: awayGoals,
    );

    // Mark fixture as played
    final newFixtures = [...state.fixtures];
    newFixtures[fxIndex] = fx.markPlayed(homeGoals, awayGoals);

    // Update table
    var newTable = state.table.applyMatch(
      home: fullHome.name,
      away: fullAway.name,
      homeGoals: homeGoals,
      awayGoals: awayGoals,
    );

    // Simulate AI vs AI
    final others = state.aiTeams.where((t) => t != fullAway.name).toList();
    others.shuffle(_rng);
    for (int i = 0; i + 1 < others.length; i += 2) {
      final a = others[i];
      final b = others[i + 1];
      final hg = _poisson(1.4 + _rng.nextDouble());
      final ag = _poisson(1.2 + _rng.nextDouble());
      newTable = newTable.applyMatch(
        home: a,
        away: b,
        homeGoals: hg,
        awayGoals: ag,
      );
    }

    // Commit
    state = state.copyWith(
      myTeam: fullHome.copyWith(squad: finalSquad),
      opponent: fullAway,
      history: [...state.history, played],
      fixtures: newFixtures,
      table: newTable,
      lastMatchMoments: sim.moments,
      lastMatchScore: sim.score,
      lastMatchPlayerStats: sim.playerStats,
    );

    // Notifies
    _notify('Skills', 'Earned $spGain SP from match performance!');
    _notify(
      'Match',
      MatchMessages.result(
        state.week,
        fullHome.name,
        homeGoals,
        fullAway.name,
        awayGoals,
      ),
    );
  }


  int _poisson(double lambda) {
    final L = _exp(-lambda);
    int k = 0;
    double p = 1.0;
    do {
      k++;
      p *= _rng.nextDouble();
    } while (p > L);
    return k - 1;
  }

  double _exp(double x) => x == 0 ? 1 : (x > 0 ? _expPos(x) : 1 / _expPos(-x));

  double _expPos(double x) {
    double sum = 1, term = 1;
    for (int n = 1; n < 16; n++) {
      term *= x / n;
      sum += term;
    }
    return sum;
  }

  // Convenience for potential fallback use-cases (not used in fixture flow)
  void _playAndRecord(String home, String away) {
    final r = _match.play(state.myTeam, state.opponent);

    // Declarar as variáveis primeiro
    final homeGoals = r.homeGoals;
    final awayGoals = r.awayGoals;
    final homeRepDelta = r.homeRepDelta;

    final upd = state.myTeam.squad
        .map(
          (p) => p.id == _meId
              ? p.copyWith(
                  reputation: (p.reputation + homeRepDelta).clamp(0, 100),
                  form: (p.form * 0.98 + (homeGoals > 0 ? 0.04 : 0.02)).clamp(
                    0,
                    1,
                  ),
                  fatigue: (p.fatigue + 0.15).clamp(0, 1),
                )
              : p,
        )
        .toList();

    final played = PlayedMatch(
      week: state.week,
      homeName: home,
      awayName: away,
      homeGoals: r.homeGoals,
      awayGoals: r.awayGoals,
    );

    final newTable = state.table.applyMatch(
      home: home,
      away: away,
      homeGoals: r.homeGoals,
      awayGoals: r.awayGoals,
    );

    state = state.copyWith(
      myTeam: state.myTeam.copyWith(squad: upd),
      history: [...state.history, played],
      table: newTable,
    );
  }

  // =========================
  // WEEKLY LOOP
  // =========================

  /// Advance full weekly loop focado no jogador:
  Future<void> advanceWeek() async {
    // 1) match
    playMatch();

    // 2) passive train + recovery
    final trained = _training.passiveWeeklyTraining(_me);
    final rested = _training.rest(trained);
    _commitMe(rested);

    // 3) Economy and next week
    endOfWeekEconomy();
  }

  /// Simular várias semanas seguidas
  Future<void> simulateWeeks(int n) async {
    if (n <= 0) return;
    for (int i = 0; i < n; i++) {
      await advanceWeek();
    }
  }

  // =========================
  // NOTIFICATIONS HELPER
  // =========================

  void _notify(String title, String body) {
    ref
        .read(notificationsProvider.notifier)
        .push(
          AppMessage(
            id: DateTime.now().microsecondsSinceEpoch.toString(),
            title: title,
            body: body,
            ts: DateTime.now(),
          ),
        );
  }

  // Em game_controller.dart, após o jogo:
  void _notifyMatchSPRewards(Map<String, PlayerStats> stats) {
    final meStats = stats[_meId];
    if (meStats != null && meStats.spEarned > 0) {
      _notify(
        'Skills',
        'Earned ${meStats.spEarned} SP from match performance!',
      );
    }
  }

  // =========================
  // COACH TRUST (derived)
  // =========================

  /// Métrica derivada 0..1 baseada na tua forma (60%) e reputação (40%).
  double get coachTrust {
    final f = _me.form; // 0..1
    final rep = _me.reputation; // 0..100
    final trust = 0.6 * f + 0.4 * (rep / 100.0);
    return trust.clamp(0, 1);
  }

  /// Conveniência para status textual com base no trust.
  String get coachStatus {
    final t = coachTrust;
    if (t >= 0.75) return 'Starter';
    if (t >= 0.55) return 'Rotation';
    return 'Bench';
  }

  // =========================
  // PLAYER CONTRACT / AGENT
  // =========================

  /// Pede transferência — só cria um evento/notification do agente/coach.
  void requestTransfer() {
    final lines = [
      'Your agent: A transfer request has been filed.',
      'Coach will review your status this month.',
      'Stay focused: performance affects interest from other clubs.',
    ];
    _notify('Agent', lines.join(' '));
  }

  /// Pede aumento com probabilidade baseada no Coach Trust.
  /// Base chance = coachTrust; “pedidos fáceis” têm +10% de bónus.
  void askForRaise() {
    final base = coachTrust; // 0..1
    final bonus = 0.10; // indulgência
    final chance = (base + bonus).clamp(0, 0.95); // cap 95%
    final roll = _rng.nextDouble(); // 0..1

    final cur = state.economy;
    if (roll < chance) {
      // aprovação simples: +10% arredondado
      final inc = (cur.weeklyIncome * 0.10).round();
      final next = cur.copyWith(weeklyIncome: cur.weeklyIncome + inc);
      state = state.copyWith(economy: next);
      _notify(
        'Agent',
        'Raise approved (+\$${inc}/week). New salary: \$${next.weeklyIncome}/week.',
      );
    } else {
      _notify(
        'Coach',
        'Raise denied for now. Improve your form & reputation to increase chances.',
      );
    }
  }

  // DUMMY PLAYER //

  Player _createInitialPlayer() {
    // Initialize all 28 skills with base values
    final Map<String, Skill> allSkills = {};

    for (final entry in SkillsCatalog.all28Skills.entries) {
      allSkills[entry.key] = entry.value.copyWith(
        level: 45 + _rng.nextInt(20), // Random 45-65
        currentXp: _rng.nextInt(30),
      );
    }

    return Player(
      id: "p1",
      name: "Rui Silva",
      age: 22,
      role: PlayerRole.midfielder,
      // Or striker/defender
      skills: allSkills,
      form: 0.8,
      fatigue: 0.2,
      reputation: 15.0,
      sp: 10,
      // Starting SP
      consistency: 55.0,
      determination: 60.0,
      leadership: 45.0,
    );
  }

  // =========================
  // SKILLS SYSTEM
  // =========================

  /// Train a specific skill using the new XP system
  void trainSkillWithXP(String skillId) {
    final me = _me;
    final updatedPlayer = _training.trainSkill(me, skillId, baseXp: 30);
    _commitMe(updatedPlayer);

    final skill = updatedPlayer.skills[skillId];
    if (skill != null) {
      _notify('Training', 'Trained $skillId - Level ${skill.level}');
    }
  }

  /// Use SP to boost a skill
  void useSpOnSkill(String skillId, int spAmount) {
    if (spAmount <= 0 || spAmount > _me.sp) return;

    final updatedPlayer = _training.useSpOnSkill(_me, skillId, spAmount);
    _commitMe(updatedPlayer);

    _notify('Skills', 'Used $spAmount SP on ${skillId}');
  }

  /// Promote a single skill (pay cost)
  void promoteSkill(String skillId) {
    final skill = _me.skills[skillId];
    if (skill == null || skill.queuedLevels <= 0) return;

    final cost = skill.promotionCost(skill.level);
    if (state.economy.cash < cost) {
      _notify('Skills', 'Not enough cash to promote (need \$$cost)');
      return;
    }

    final (updatedPlayer, success, actualCost) = _training.promoteSkill(
      _me,
      skillId,
      state.economy.cash,
    );

    if (success) {
      _commitMe(updatedPlayer);
      addExpense(actualCost);

      final newSkill = updatedPlayer.skills[skillId];
      _notify('Skills', 'Promoted ${skillId} to level ${newSkill?.level ?? 0}');
    }
  }

  /// Promote all queued skills
  void promoteAllSkills() {
    final (updatedPlayer, totalCost, promotedSkills) = _training
        .promoteAllSkills(_me, state.economy.cash);

    if (promotedSkills.isNotEmpty) {
      _commitMe(updatedPlayer);
      addExpense(totalCost);
      _notify(
        'Skills',
        'Promoted ${promotedSkills.length} skills for \$$totalCost',
      );
    } else {
      _notify('Skills', 'No skills to promote or insufficient funds');
    }
  }

  /// Weekly passive training (called in advanceWeek)
  void _applyWeeklyTraining() {
    final updatedPlayer = _training.passiveWeeklyTraining(_me);
    _commitMe(updatedPlayer);
  }

  // --- XI helpers ---

  bool _isGK(Player p) {
    final n = p.role.name.toLowerCase();
    return n.contains('gk') ||
        n.contains('goal'); // matches 'gk' or 'goalkeeper'
  }

  PlayerRole _findRole(List<String> hints) {
    // Tries each hint until it finds a role name that contains it
    for (final h in hints) {
      final i = PlayerRole.values.indexWhere(
        (r) => r.name.toLowerCase().contains(h),
      );
      if (i != -1) return PlayerRole.values[i];
    }
    // fallback to the first role if nothing matches
    return PlayerRole.values.first;
  }

  String _randName() {
    const first = [
      'Joao',
      'Miguel',
      'Rui',
      'Tiago',
      'Luis',
      'Pedro',
      'Carlos',
      'Bruno',
      'Andre',
      'Diogo',
      'Marco',
      'Ricardo',
      'Daniel',
      'Hugo',
      'Paulo',
    ];
    const last = [
      'Silva',
      'Santos',
      'Pereira',
      'Rodrigues',
      'Ferreira',
      'Costa',
      'Martins',
      'Araujo',
      'Gomes',
      'Carvalho',
      'Sousa',
      'Rocha',
      'Mendes',
      'Barbosa',
      'Almeida',
    ];
    return '${first[_rng.nextInt(first.length)]} ${last[_rng.nextInt(last.length)]}';
  }

  Map<String, Skill> _baseSkillsWithNoise() {
    final out = <String, Skill>{};
    // Uses your catalog; adjust import path if needed
    SkillsCatalog.all28Skills.forEach((id, base) {
      out[id] = base.copyWith(
        level: 45 + _rng.nextInt(26), // 45..70
        currentXp: _rng.nextInt(30),
      );
    });
    return out;
  }

  Player _makeAIPlayer({
    required String teamId,
    required int index,
    required PlayerRole role,
  }) {
    return Player(
      id: 'ai_${teamId}_$index',
      name: _randName(),
      age: 18 + _rng.nextInt(15),
      role: role,
      skills: _baseSkillsWithNoise(),
      form: 0.6 + _rng.nextDouble() * 0.3,
      fatigue: _rng.nextDouble() * 0.25,
      reputation: 5 + _rng.nextDouble() * 20,
      sp: 0,
      consistency: 50 + _rng.nextInt(30).toDouble(),
      determination: 50 + _rng.nextInt(30).toDouble(),
      leadership: 40 + _rng.nextInt(35).toDouble(),
    );
  }

  Team _ensureXI(Team t) {
    final squad = [...t.squad];

    // Ensure exactly one GK if none present
    if (!squad.any(_isGK)) {
      final gkRole = _findRole(['gk', 'goal']);
      squad.add(
        _makeAIPlayer(teamId: t.id, index: squad.length + 1, role: gkRole),
      );
    }

    // Fill up to 11 with a 4-4-2-ish template
    final wantedOrder = <PlayerRole>[
      _findRole(['cb', 'def']),
      _findRole(['cb', 'def']),
      _findRole(['wing', 'back', 'def']),
      _findRole(['wing', 'back', 'def']),
      _findRole(['mid', 'cm']),
      _findRole(['mid', 'cm']),
      _findRole(['mid', 'cm']),
      _findRole(['mid', 'cm']),
      _findRole(['striker', 'st', 'forward']),
      _findRole(['striker', 'st', 'forward']),
    ];

    // Add from template until we reach 11
    var idx = 0;
    while (squad.length < 11) {
      final role = (idx < wantedOrder.length)
          ? wantedOrder[idx]
          : _findRole(['mid', 'cm']);
      squad.add(
        _makeAIPlayer(teamId: t.id, index: squad.length + 1, role: role),
      );
      idx++;
    }

    return t.copyWith(squad: squad);
  }
}
---
// FILE: lib/app/controllers/notifications_controller.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/models/app_message.dart';

---
class NotificationsController extends StateNotifier<List<AppMessage>> {
  NotificationsController() : super(const []);

  void push(AppMessage msg) {
    state = [msg, ...state];
  }

  void markRead(String id) {
    state = [
      for (final m in state)
        if (m.id == id) m.copyWith(read: true) else m
    ];
  }

  void clearAll() => state = const [];
}
---
// FILE: lib/app/providers/providers.dart
// lib/app/providers/providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/models/app_message.dart';
import '../controllers/game_controller.dart';
import '../controllers/notifications_controller.dart';
import '../state/game_state.dart';

final gameControllerProvider =
NotifierProvider<GameController, GameState>(() => GameController());

// Single notifications provider
final notificationsProvider =
StateNotifierProvider<NotificationsController, List<AppMessage>>(
      (ref) => NotificationsController(),
);
---
// FILE: lib/app/state/game_state.dart
import '../../domain/models/team.dart';
import '../../domain/models/league.dart';
import '../../domain/models/economy.dart';
import '../../domain/models/business.dart';
import '../../domain/models/played_match.dart';
import '../../domain/models/fixture.dart';
import '../../domain/models/league_table.dart';
import '../../features/match/models/match_moment.dart';

---
class GameState {
  final Team myTeam;
  final Team opponent;
  final League league;
  final Economy economy;
  final int week; // drives the current fixture
  final List<PlayedMatch> history;
  final List<Fixture> fixtures;
  final LeagueTable table;
  final List<String> aiTeams;

  // NEW: businesses
  final List<Business> catalogBusinesses; // available to buy (templates)
  final List<Business> myBusinesses; // owned with levels

  //for match moments
  final List<MatchMoment> lastMatchMoments;
  final MatchScore? lastMatchScore;
  final Map<String, PlayerStats> lastMatchPlayerStats;

  const GameState({
    required this.myTeam,
    required this.opponent,
    required this.league,
    required this.economy,
    required this.week,
    required this.history,
    required this.fixtures,
    required this.table,
    required this.aiTeams,
    this.catalogBusinesses = const [],
    this.myBusinesses = const [],
    this.lastMatchMoments = const <MatchMoment>[],
    this.lastMatchScore,
    this.lastMatchPlayerStats = const <String, PlayerStats>{},
  });

  GameState copyWith({
    Team? myTeam,
    Team? opponent,
    League? league,
    Economy? economy,
    int? week,
    List<PlayedMatch>? history,
    List<Fixture>? fixtures,
    LeagueTable? table,
    List<String>? aiTeams,
    List<Business>? catalogBusinesses,
    List<Business>? myBusinesses,
    Iterable<MatchMoment>? lastMatchMoments,
    MatchScore? lastMatchScore,
    Map<String, PlayerStats>? lastMatchPlayerStats,
  }) {
    return GameState(
      myTeam: myTeam ?? this.myTeam,
      opponent: opponent ?? this.opponent,
      league: league ?? this.league,
      economy: economy ?? this.economy,
      week: week ?? this.week,
      history: history ?? this.history,
      fixtures: fixtures ?? this.fixtures,
      table: table ?? this.table,
      aiTeams: aiTeams ?? this.aiTeams,
      catalogBusinesses: catalogBusinesses ?? this.catalogBusinesses,
      myBusinesses: myBusinesses ?? this.myBusinesses,
      lastMatchMoments: lastMatchMoments != null
          ? List<MatchMoment>.from(lastMatchMoments)
          : this.lastMatchMoments,
      lastMatchScore: lastMatchScore ?? this.lastMatchScore,
      lastMatchPlayerStats: lastMatchPlayerStats ?? this.lastMatchPlayerStats,
    );
  }
}
---
// FILE: lib/core/l10n/app_localizations.dart
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_en.dart';
import 'app_localizations_pt.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'l10n/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you’ll need to edit this
/// file.
///
/// First, open your project’s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project’s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
---
abstract class AppLocalizations {
  AppLocalizations(String locale)
    : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
        delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
      ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('en'),
    Locale('pt'),
  ];

  /// No description provided for @notifications_economy.
  ///
  /// In en, this message translates to:
  /// **'Economy'**
  String get notifications_economy;

  /// No description provided for @notifications_general.
  ///
  /// In en, this message translates to:
  /// **'General'**
  String get notifications_general;

  /// No description provided for @notifications_match.
  ///
  /// In en, this message translates to:
  /// **'Match'**
  String get notifications_match;

  /// No description provided for @notifications_skills.
  ///
  /// In en, this message translates to:
  /// **'Skills'**
  String get notifications_skills;

  /// No description provided for @notifications_economy_week_summary.
  ///
  /// In en, this message translates to:
  /// **'Revenue: {revenue} • Costs: {costs} • Delta: {delta} • Balance: {balance}'**
  String notifications_economy_week_summary(
    Object balance,
    Object costs,
    Object delta,
    Object revenue,
  );

  /// No description provided for @notifications_week_finished.
  ///
  /// In en, this message translates to:
  /// **'Week {week} finished'**
  String notifications_week_finished(Object week);

  /// No description provided for @notifications_match_result.
  ///
  /// In en, this message translates to:
  /// **'Result — Week {week}\n{home} {score} {away}'**
  String notifications_match_result(
    Object away,
    Object home,
    Object score,
    Object week,
  );

  /// No description provided for @notifications_skills_promoted_count.
  ///
  /// In en, this message translates to:
  /// **'Promoted {count} skills for {cost}'**
  String notifications_skills_promoted_count(Object cost, Object count);

  /// No description provided for @startDate.
  ///
  /// In en, this message translates to:
  /// **'Start Date'**
  String get startDate;

  /// No description provided for @endDate.
  ///
  /// In en, this message translates to:
  /// **'End Date'**
  String get endDate;

  /// No description provided for @cleanSheet.
  ///
  /// In en, this message translates to:
  /// **'Clean Sheet'**
  String get cleanSheet;

  /// No description provided for @manOfTheMatch.
  ///
  /// In en, this message translates to:
  /// **'Man of the Match'**
  String get manOfTheMatch;

  /// No description provided for @wageRiseAfter20Games.
  ///
  /// In en, this message translates to:
  /// **'Wage Rise After 20 Games'**
  String get wageRiseAfter20Games;

  /// No description provided for @afterNYears.
  ///
  /// In en, this message translates to:
  /// **'after {years} years'**
  String afterNYears(int years);

  /// No description provided for @yearsDur.
  ///
  /// In en, this message translates to:
  /// **'{count} years'**
  String yearsDur(int count);

  /// No description provided for @positionShort.
  ///
  /// In en, this message translates to:
  /// **'#'**
  String get positionShort;

  /// No description provided for @acceleration.
  ///
  /// In en, this message translates to:
  /// **'Acceleration'**
  String get acceleration;

  /// No description provided for @achievements.
  ///
  /// In en, this message translates to:
  /// **'Achievements'**
  String get achievements;

  /// No description provided for @actions.
  ///
  /// In en, this message translates to:
  /// **'Actions'**
  String get actions;

  /// No description provided for @agility.
  ///
  /// In en, this message translates to:
  /// **'Agility'**
  String get agility;

  /// No description provided for @annual.
  ///
  /// In en, this message translates to:
  /// **'Annual'**
  String get annual;

  /// No description provided for @anticipation.
  ///
  /// In en, this message translates to:
  /// **'Anticipation'**
  String get anticipation;

  /// No description provided for @assists.
  ///
  /// In en, this message translates to:
  /// **'Assists'**
  String get assists;

  /// No description provided for @bravery.
  ///
  /// In en, this message translates to:
  /// **'Bravery'**
  String get bravery;

  /// No description provided for @cancel.
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get cancel;

  /// No description provided for @career.
  ///
  /// In en, this message translates to:
  /// **'Career'**
  String get career;

  /// No description provided for @cash.
  ///
  /// In en, this message translates to:
  /// **'Cash'**
  String get cash;

  /// No description provided for @casino.
  ///
  /// In en, this message translates to:
  /// **'Casino'**
  String get casino;

  /// No description provided for @clauses.
  ///
  /// In en, this message translates to:
  /// **'Clauses'**
  String get clauses;

  /// No description provided for @composure.
  ///
  /// In en, this message translates to:
  /// **'Composure'**
  String get composure;

  /// No description provided for @consistency.
  ///
  /// In en, this message translates to:
  /// **'Consistency'**
  String get consistency;

  /// No description provided for @costs.
  ///
  /// In en, this message translates to:
  /// **'Costs'**
  String get costs;

  /// No description provided for @drawsShort.
  ///
  /// In en, this message translates to:
  /// **'D'**
  String get drawsShort;

  /// No description provided for @determination.
  ///
  /// In en, this message translates to:
  /// **'Determination'**
  String get determination;

  /// No description provided for @dribbling.
  ///
  /// In en, this message translates to:
  /// **'Dribbling'**
  String get dribbling;

  /// No description provided for @duration.
  ///
  /// In en, this message translates to:
  /// **'Duration'**
  String get duration;

  /// No description provided for @economy.
  ///
  /// In en, this message translates to:
  /// **'Economy'**
  String get economy;

  /// No description provided for @english.
  ///
  /// In en, this message translates to:
  /// **'English'**
  String get english;

  /// No description provided for @fatigue.
  ///
  /// In en, this message translates to:
  /// **'Fatigue'**
  String get fatigue;

  /// No description provided for @finance.
  ///
  /// In en, this message translates to:
  /// **'Finance'**
  String get finance;

  /// No description provided for @finishing.
  ///
  /// In en, this message translates to:
  /// **'Finishing'**
  String get finishing;

  /// No description provided for @flexibility.
  ///
  /// In en, this message translates to:
  /// **'Flexibility'**
  String get flexibility;

  /// No description provided for @form.
  ///
  /// In en, this message translates to:
  /// **'Form'**
  String get form;

  /// No description provided for @goalsAgainstShort.
  ///
  /// In en, this message translates to:
  /// **'GA'**
  String get goalsAgainstShort;

  /// No description provided for @goalDifferenceShort.
  ///
  /// In en, this message translates to:
  /// **'GD'**
  String get goalDifferenceShort;

  /// No description provided for @general.
  ///
  /// In en, this message translates to:
  /// **'General'**
  String get general;

  /// No description provided for @goalsForShort.
  ///
  /// In en, this message translates to:
  /// **'GF'**
  String get goalsForShort;

  /// No description provided for @goals.
  ///
  /// In en, this message translates to:
  /// **'Goals'**
  String get goals;

  /// No description provided for @good.
  ///
  /// In en, this message translates to:
  /// **'Good'**
  String get good;

  /// No description provided for @heading.
  ///
  /// In en, this message translates to:
  /// **'Heading'**
  String get heading;

  /// No description provided for @home.
  ///
  /// In en, this message translates to:
  /// **'Home'**
  String get home;

  /// No description provided for @income.
  ///
  /// In en, this message translates to:
  /// **'Income'**
  String get income;

  /// No description provided for @investments.
  ///
  /// In en, this message translates to:
  /// **'Investments'**
  String get investments;

  /// No description provided for @jumping.
  ///
  /// In en, this message translates to:
  /// **'Jumping'**
  String get jumping;

  /// No description provided for @lossesShort.
  ///
  /// In en, this message translates to:
  /// **'L'**
  String get lossesShort;

  /// No description provided for @language.
  ///
  /// In en, this message translates to:
  /// **'Language'**
  String get language;

  /// No description provided for @leadership.
  ///
  /// In en, this message translates to:
  /// **'Leadership'**
  String get leadership;

  /// No description provided for @lifestyle.
  ///
  /// In en, this message translates to:
  /// **'Lifestyle'**
  String get lifestyle;

  /// No description provided for @marking.
  ///
  /// In en, this message translates to:
  /// **'Marking'**
  String get marking;

  /// No description provided for @matches.
  ///
  /// In en, this message translates to:
  /// **'Matches'**
  String get matches;

  /// No description provided for @mental.
  ///
  /// In en, this message translates to:
  /// **'Mental'**
  String get mental;

  /// No description provided for @morale.
  ///
  /// In en, this message translates to:
  /// **'Morale'**
  String get morale;

  /// No description provided for @negotiate.
  ///
  /// In en, this message translates to:
  /// **'Negotiate'**
  String get negotiate;

  /// No description provided for @newOffer.
  ///
  /// In en, this message translates to:
  /// **'NEW'**
  String get newOffer;

  /// No description provided for @notifications.
  ///
  /// In en, this message translates to:
  /// **'Notifications'**
  String get notifications;

  /// No description provided for @ok.
  ///
  /// In en, this message translates to:
  /// **'OK'**
  String get ok;

  /// No description provided for @ovr.
  ///
  /// In en, this message translates to:
  /// **'OVR'**
  String get ovr;

  /// No description provided for @playedShort.
  ///
  /// In en, this message translates to:
  /// **'P'**
  String get playedShort;

  /// No description provided for @physical.
  ///
  /// In en, this message translates to:
  /// **'Physical'**
  String get physical;

  /// No description provided for @play.
  ///
  /// In en, this message translates to:
  /// **'Play'**
  String get play;

  /// No description provided for @portuguese.
  ///
  /// In en, this message translates to:
  /// **'Portuguese'**
  String get portuguese;

  /// No description provided for @positioning.
  ///
  /// In en, this message translates to:
  /// **'Positioning'**
  String get positioning;

  /// No description provided for @power.
  ///
  /// In en, this message translates to:
  /// **'Power'**
  String get power;

  /// No description provided for @preview.
  ///
  /// In en, this message translates to:
  /// **'Preview'**
  String get preview;

  /// No description provided for @profile.
  ///
  /// In en, this message translates to:
  /// **'Profile'**
  String get profile;

  /// No description provided for @pointsShort.
  ///
  /// In en, this message translates to:
  /// **'Pts'**
  String get pointsShort;

  /// No description provided for @ratings.
  ///
  /// In en, this message translates to:
  /// **'Ratings'**
  String get ratings;

  /// No description provided for @recovery.
  ///
  /// In en, this message translates to:
  /// **'Recovery'**
  String get recovery;

  /// No description provided for @reject.
  ///
  /// In en, this message translates to:
  /// **'Reject'**
  String get reject;

  /// No description provided for @rep.
  ///
  /// In en, this message translates to:
  /// **'Rep'**
  String get rep;

  /// No description provided for @role.
  ///
  /// In en, this message translates to:
  /// **'Role'**
  String get role;

  /// No description provided for @roleRotation.
  ///
  /// In en, this message translates to:
  /// **'Rotation'**
  String get roleRotation;

  /// No description provided for @salary.
  ///
  /// In en, this message translates to:
  /// **'Salary'**
  String get salary;

  /// No description provided for @settings.
  ///
  /// In en, this message translates to:
  /// **'Settings'**
  String get settings;

  /// No description provided for @skills.
  ///
  /// In en, this message translates to:
  /// **'Skills'**
  String get skills;

  /// No description provided for @squad.
  ///
  /// In en, this message translates to:
  /// **'Squad'**
  String get squad;

  /// No description provided for @stamina.
  ///
  /// In en, this message translates to:
  /// **'Stamina'**
  String get stamina;

  /// No description provided for @standings.
  ///
  /// In en, this message translates to:
  /// **'Standings'**
  String get standings;

  /// No description provided for @roleStarter.
  ///
  /// In en, this message translates to:
  /// **'Starter'**
  String get roleStarter;

  /// No description provided for @stats.
  ///
  /// In en, this message translates to:
  /// **'Stats'**
  String get stats;

  /// No description provided for @store.
  ///
  /// In en, this message translates to:
  /// **'Store'**
  String get store;

  /// No description provided for @tackling.
  ///
  /// In en, this message translates to:
  /// **'Tackling'**
  String get tackling;

  /// No description provided for @team.
  ///
  /// In en, this message translates to:
  /// **'Team'**
  String get team;

  /// No description provided for @technical.
  ///
  /// In en, this message translates to:
  /// **'Technical'**
  String get technical;

  /// No description provided for @technique.
  ///
  /// In en, this message translates to:
  /// **'Technique'**
  String get technique;

  /// No description provided for @train.
  ///
  /// In en, this message translates to:
  /// **'Train'**
  String get train;

  /// No description provided for @vision.
  ///
  /// In en, this message translates to:
  /// **'Vision'**
  String get vision;

  /// No description provided for @winsShort.
  ///
  /// In en, this message translates to:
  /// **'W'**
  String get winsShort;

  /// No description provided for @week.
  ///
  /// In en, this message translates to:
  /// **'Week'**
  String get week;

  /// No description provided for @weekly.
  ///
  /// In en, this message translates to:
  /// **'Weekly'**
  String get weekly;

  /// No description provided for @wWeek.
  ///
  /// In en, this message translates to:
  /// **'W{week}'**
  String wWeek(int week);

  /// No description provided for @years.
  ///
  /// In en, this message translates to:
  /// **'years'**
  String get years;

  /// No description provided for @activeContract.
  ///
  /// In en, this message translates to:
  /// **'Active Contract'**
  String get activeContract;

  /// No description provided for @addDemoMessage.
  ///
  /// In en, this message translates to:
  /// **'Add demo message'**
  String get addDemoMessage;

  /// No description provided for @advanceWeek.
  ///
  /// In en, this message translates to:
  /// **'Advance Week'**
  String get advanceWeek;

  /// No description provided for @ageAge.
  ///
  /// In en, this message translates to:
  /// **'Age {age}'**
  String ageAge(int age);

  /// No description provided for @agentRelationship.
  ///
  /// In en, this message translates to:
  /// **'Agent Relationship'**
  String get agentRelationship;

  /// No description provided for @bestRatings.
  ///
  /// In en, this message translates to:
  /// **'Best Ratings'**
  String get bestRatings;

  /// No description provided for @bodyStrength.
  ///
  /// In en, this message translates to:
  /// **'Body Strength'**
  String get bodyStrength;

  /// No description provided for @investmentsSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Business portfolio'**
  String get investmentsSubtitle;

  /// No description provided for @careerStatistics.
  ///
  /// In en, this message translates to:
  /// **'Career statistics'**
  String get careerStatistics;

  /// No description provided for @careerStats.
  ///
  /// In en, this message translates to:
  /// **'Career Stats'**
  String get careerStats;

  /// No description provided for @cashPacksAndPremium.
  ///
  /// In en, this message translates to:
  /// **'Cash packs & Premium'**
  String get cashPacksAndPremium;

  /// No description provided for @casinoLoss.
  ///
  /// In en, this message translates to:
  /// **'Casino loss! You lost {loss}. New cash: {cash}'**
  String casinoLoss(double loss, double cash);

  /// No description provided for @casinoWin.
  ///
  /// In en, this message translates to:
  /// **'Casino win! You won {delta}. New cash: {cash}'**
  String casinoWin(double delta, double cash);

  /// No description provided for @casinoAllIn.
  ///
  /// In en, this message translates to:
  /// **'Casino — All In'**
  String get casinoAllIn;

  /// No description provided for @casinoPlaceBet.
  ///
  /// In en, this message translates to:
  /// **'Casino — Place Bet'**
  String get casinoPlaceBet;

  /// No description provided for @claimFreeRewards.
  ///
  /// In en, this message translates to:
  /// **'Claim free rewards'**
  String get claimFreeRewards;

  /// No description provided for @clearAll.
  ///
  /// In en, this message translates to:
  /// **'Clear all'**
  String get clearAll;

  /// No description provided for @coachTrust.
  ///
  /// In en, this message translates to:
  /// **'Coach Trust'**
  String get coachTrust;

  /// No description provided for @contractDetails.
  ///
  /// In en, this message translates to:
  /// **'Contract Details'**
  String get contractDetails;

  /// No description provided for @profileSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Contract, wages & agent'**
  String get profileSubtitle;

  /// No description provided for @contractWagesAgent.
  ///
  /// In en, this message translates to:
  /// **'Contract, wages & agent'**
  String get contractWagesAgent;

  /// No description provided for @nationalStandingsSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Country rankings'**
  String get nationalStandingsSubtitle;

  /// No description provided for @countryRankings.
  ///
  /// In en, this message translates to:
  /// **'Country rankings'**
  String get countryRankings;

  /// No description provided for @currentBalance.
  ///
  /// In en, this message translates to:
  /// **'Current Balance'**
  String get currentBalance;

  /// No description provided for @endWeekApplyEconomy.
  ///
  /// In en, this message translates to:
  /// **'End Week (Apply Economy)'**
  String get endWeekApplyEconomy;

  /// No description provided for @enterAnyAmount.
  ///
  /// In en, this message translates to:
  /// **'Enter any amount (up to your cash)'**
  String get enterAnyAmount;

  /// No description provided for @firstTouch.
  ///
  /// In en, this message translates to:
  /// **'First Touch'**
  String get firstTouch;

  /// No description provided for @footyStar.
  ///
  /// In en, this message translates to:
  /// **'Footy Star'**
  String get footyStar;

  /// No description provided for @goToMatches.
  ///
  /// In en, this message translates to:
  /// **'Go to Matches'**
  String get goToMatches;

  /// No description provided for @hourlyRewards.
  ///
  /// In en, this message translates to:
  /// **'Hourly Rewards'**
  String get hourlyRewards;

  /// No description provided for @lifestyleSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Housing, cars, luxury items'**
  String get lifestyleSubtitle;

  /// No description provided for @housingCarsLuxuryItems.
  ///
  /// In en, this message translates to:
  /// **'Housing, cars, luxury items'**
  String get housingCarsLuxuryItems;

  /// No description provided for @inboundTransfers.
  ///
  /// In en, this message translates to:
  /// **'Inbound Transfers'**
  String get inboundTransfers;

  /// No description provided for @weekSummary.
  ///
  /// In en, this message translates to:
  /// **'Income: \${earned} • Costs: \${spent} • Delta: {delta} • Cash: \${cash}'**
  String weekSummary(int earned, int spent, int delta, int cash);

  /// No description provided for @languageChanged.
  ///
  /// In en, this message translates to:
  /// **'Language changed'**
  String get languageChanged;

  /// No description provided for @leagueTable.
  ///
  /// In en, this message translates to:
  /// **'League table'**
  String get leagueTable;

  /// No description provided for @longPassing.
  ///
  /// In en, this message translates to:
  /// **'Long Passing'**
  String get longPassing;

  /// No description provided for @longShots.
  ///
  /// In en, this message translates to:
  /// **'Long Shots'**
  String get longShots;

  /// No description provided for @loyaltyBonus.
  ///
  /// In en, this message translates to:
  /// **'Loyalty Bonus'**
  String get loyaltyBonus;

  /// No description provided for @lvLevel.
  ///
  /// In en, this message translates to:
  /// **'Lv {level}'**
  String lvLevel(int level);

  /// No description provided for @matchPlayedFriendly.
  ///
  /// In en, this message translates to:
  /// **'Match played\n{home} vs {away} (friendly/unscheduled)'**
  String matchPlayedFriendly(Object home, Object away);

  /// No description provided for @matchResult.
  ///
  /// In en, this message translates to:
  /// **'Match result — Week {week}\n{home} {hg} - {ag} {away}'**
  String matchResult(int week, Object home, int hg, int ag, Object away);

  /// No description provided for @matchScheduled.
  ///
  /// In en, this message translates to:
  /// **'Match scheduled'**
  String get matchScheduled;

  /// No description provided for @myTeam.
  ///
  /// In en, this message translates to:
  /// **'My Team'**
  String get myTeam;

  /// No description provided for @myTraining.
  ///
  /// In en, this message translates to:
  /// **'My Training'**
  String get myTraining;

  /// No description provided for @nationalRankingsPlaceholder.
  ///
  /// In en, this message translates to:
  /// **'National rankings will be shown here'**
  String get nationalRankingsPlaceholder;

  /// No description provided for @nationalStandings.
  ///
  /// In en, this message translates to:
  /// **'National Standings'**
  String get nationalStandings;

  /// No description provided for @nextMatch.
  ///
  /// In en, this message translates to:
  /// **'Next match'**
  String get nextMatch;

  /// No description provided for @nextOpponent.
  ///
  /// In en, this message translates to:
  /// **'Next opponent: {opponent}'**
  String nextOpponent(Object opponent);

  /// No description provided for @noFixturesScheduled.
  ///
  /// In en, this message translates to:
  /// **'No fixtures scheduled'**
  String get noFixturesScheduled;

  /// No description provided for @noNotifications.
  ///
  /// In en, this message translates to:
  /// **'No notifications yet'**
  String get noNotifications;

  /// No description provided for @noStandingsYet.
  ///
  /// In en, this message translates to:
  /// **'No standings yet. Play a match to populate the table.'**
  String get noStandingsYet;

  /// No description provided for @perAssist.
  ///
  /// In en, this message translates to:
  /// **'Per Assist'**
  String get perAssist;

  /// No description provided for @perGoal.
  ///
  /// In en, this message translates to:
  /// **'Per Goal'**
  String get perGoal;

  /// No description provided for @performanceBonuses.
  ///
  /// In en, this message translates to:
  /// **'Performance Bonuses'**
  String get performanceBonuses;

  /// No description provided for @playAdvance.
  ///
  /// In en, this message translates to:
  /// **'Play & Advance'**
  String get playAdvance;

  /// No description provided for @playersStandings.
  ///
  /// In en, this message translates to:
  /// **'Players Standings'**
  String get playersStandings;

  /// No description provided for @previewSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Quick preview of common labels'**
  String get previewSubtitle;

  /// No description provided for @realMoneyPurchases.
  ///
  /// In en, this message translates to:
  /// **'Real Money Purchases'**
  String get realMoneyPurchases;

  /// No description provided for @recoverySession.
  ///
  /// In en, this message translates to:
  /// **'Recovery Session'**
  String get recoverySession;

  /// No description provided for @releaseClause.
  ///
  /// In en, this message translates to:
  /// **'Release Clause'**
  String get releaseClause;

  /// No description provided for @requestSalaryRaise.
  ///
  /// In en, this message translates to:
  /// **'Request Salary Raise'**
  String get requestSalaryRaise;

  /// No description provided for @requestTransfer.
  ///
  /// In en, this message translates to:
  /// **'Request Transfer'**
  String get requestTransfer;

  /// No description provided for @restAllSquad.
  ///
  /// In en, this message translates to:
  /// **'Rest All Squad'**
  String get restAllSquad;

  /// No description provided for @resultPending.
  ///
  /// In en, this message translates to:
  /// **'Result pending'**
  String get resultPending;

  /// No description provided for @resultScore.
  ///
  /// In en, this message translates to:
  /// **'Result: {hg} - {ag}'**
  String resultScore(int hg, int ag);

  /// No description provided for @newSeason.
  ///
  /// In en, this message translates to:
  /// **'Season {season} has started'**
  String newSeason(int season);

  /// No description provided for @selectLanguage.
  ///
  /// In en, this message translates to:
  /// **'Select language'**
  String get selectLanguage;

  /// No description provided for @shortPassing.
  ///
  /// In en, this message translates to:
  /// **'Short Passing'**
  String get shortPassing;

  /// No description provided for @shortShots.
  ///
  /// In en, this message translates to:
  /// **'Short Shots'**
  String get shortShots;

  /// No description provided for @sprintSpeed.
  ///
  /// In en, this message translates to:
  /// **'Sprint Speed'**
  String get sprintSpeed;

  /// No description provided for @squadRested.
  ///
  /// In en, this message translates to:
  /// **'Squad rested and recovered fatigue'**
  String get squadRested;

  /// No description provided for @statusPercent.
  ///
  /// In en, this message translates to:
  /// **'Status: {status} ({value}%)'**
  String statusPercent(Object status, int value);

  /// No description provided for @teamOverview.
  ///
  /// In en, this message translates to:
  /// **'Team overview'**
  String get teamOverview;

  /// No description provided for @thisWeeksMatch.
  ///
  /// In en, this message translates to:
  /// **'This week’s match'**
  String get thisWeeksMatch;

  /// No description provided for @topAssists.
  ///
  /// In en, this message translates to:
  /// **'Top Assists'**
  String get topAssists;

  /// No description provided for @topScorers.
  ///
  /// In en, this message translates to:
  /// **'Top Scorers'**
  String get topScorers;

  /// No description provided for @playersStandingsSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Top scorers & assists'**
  String get playersStandingsSubtitle;

  /// No description provided for @topScorersAssists.
  ///
  /// In en, this message translates to:
  /// **'Top scorers & assists'**
  String get topScorersAssists;

  /// No description provided for @inboundTransfersSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Transfer offers & negotiations'**
  String get inboundTransfersSubtitle;

  /// No description provided for @trophiesMilestones.
  ///
  /// In en, this message translates to:
  /// **'Trophies & milestones'**
  String get trophiesMilestones;

  /// No description provided for @tryYourLuck.
  ///
  /// In en, this message translates to:
  /// **'Try your luck'**
  String get tryYourLuck;

  /// No description provided for @viewContract.
  ///
  /// In en, this message translates to:
  /// **'View Contract'**
  String get viewContract;

  /// No description provided for @wagerAmount.
  ///
  /// In en, this message translates to:
  /// **'Wager amount'**
  String get wagerAmount;

  /// No description provided for @weekEnded.
  ///
  /// In en, this message translates to:
  /// **'Week {week} ended'**
  String weekEnded(int week);

  /// No description provided for @weeklyCosts.
  ///
  /// In en, this message translates to:
  /// **'Weekly Costs'**
  String get weeklyCosts;

  /// No description provided for @weeklyIncome.
  ///
  /// In en, this message translates to:
  /// **'Weekly Income'**
  String get weeklyIncome;

  /// No description provided for @skillTrained.
  ///
  /// In en, this message translates to:
  /// **'{player} improved {skill} to {level}'**
  String skillTrained(Object player, Object skill, int level);

  /// No description provided for @xpProgress.
  ///
  /// In en, this message translates to:
  /// **'{xp} / {xpMax} XP'**
  String xpProgress(int xp, int xpMax);
}

---
class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['en', 'pt'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'en':
      return AppLocalizationsEn();
    case 'pt':
      return AppLocalizationsPt();
  }

  throw FlutterError(
    'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
    'an issue with the localizations generation tool. Please file an issue '
    'on GitHub with a reproducible sample app and the gen-l10n configuration '
    'that was used.',
  );
}
---
// FILE: lib/core/l10n/app_localizations_en.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
---
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get notifications_economy => 'Economy';

  @override
  String get notifications_general => 'General';

  @override
  String get notifications_match => 'Match';

  @override
  String get notifications_skills => 'Skills';

  @override
  String notifications_economy_week_summary(
    Object balance,
    Object costs,
    Object delta,
    Object revenue,
  ) {
    return 'Revenue: $revenue • Costs: $costs • Delta: $delta • Balance: $balance';
  }

  @override
  String notifications_week_finished(Object week) {
    return 'Week $week finished';
  }

  @override
  String notifications_match_result(
    Object away,
    Object home,
    Object score,
    Object week,
  ) {
    return 'Result — Week $week\n$home $score $away';
  }

  @override
  String notifications_skills_promoted_count(Object cost, Object count) {
    return 'Promoted $count skills for $cost';
  }

  @override
  String get startDate => 'Start Date';

  @override
  String get endDate => 'End Date';

  @override
  String get cleanSheet => 'Clean Sheet';

  @override
  String get manOfTheMatch => 'Man of the Match';

  @override
  String get wageRiseAfter20Games => 'Wage Rise After 20 Games';

  @override
  String afterNYears(int years) {
    return 'after $years years';
  }

  @override
  String yearsDur(int count) {
    return '$count years';
  }

  @override
  String get positionShort => '#';

  @override
  String get acceleration => 'Acceleration';

  @override
  String get achievements => 'Achievements';

  @override
  String get actions => 'Actions';

  @override
  String get agility => 'Agility';

  @override
  String get annual => 'Annual';

  @override
  String get anticipation => 'Anticipation';

  @override
  String get assists => 'Assists';

  @override
  String get bravery => 'Bravery';

  @override
  String get cancel => 'Cancel';

  @override
  String get career => 'Career';

  @override
  String get cash => 'Cash';

  @override
  String get casino => 'Casino';

  @override
  String get clauses => 'Clauses';

  @override
  String get composure => 'Composure';

  @override
  String get consistency => 'Consistency';

  @override
  String get costs => 'Costs';

  @override
  String get drawsShort => 'D';

  @override
  String get determination => 'Determination';

  @override
  String get dribbling => 'Dribbling';

  @override
  String get duration => 'Duration';

  @override
  String get economy => 'Economy';

  @override
  String get english => 'English';

  @override
  String get fatigue => 'Fatigue';

  @override
  String get finance => 'Finance';

  @override
  String get finishing => 'Finishing';

  @override
  String get flexibility => 'Flexibility';

  @override
  String get form => 'Form';

  @override
  String get goalsAgainstShort => 'GA';

  @override
  String get goalDifferenceShort => 'GD';

  @override
  String get general => 'General';

  @override
  String get goalsForShort => 'GF';

  @override
  String get goals => 'Goals';

  @override
  String get good => 'Good';

  @override
  String get heading => 'Heading';

  @override
  String get home => 'Home';

  @override
  String get income => 'Income';

  @override
  String get investments => 'Investments';

  @override
  String get jumping => 'Jumping';

  @override
  String get lossesShort => 'L';

  @override
  String get language => 'Language';

  @override
  String get leadership => 'Leadership';

  @override
  String get lifestyle => 'Lifestyle';

  @override
  String get marking => 'Marking';

  @override
  String get matches => 'Matches';

  @override
  String get mental => 'Mental';

  @override
  String get morale => 'Morale';

  @override
  String get negotiate => 'Negotiate';

  @override
  String get newOffer => 'NEW';

  @override
  String get notifications => 'Notifications';

  @override
  String get ok => 'OK';

  @override
  String get ovr => 'OVR';

  @override
  String get playedShort => 'P';

  @override
  String get physical => 'Physical';

  @override
  String get play => 'Play';

  @override
  String get portuguese => 'Portuguese';

  @override
  String get positioning => 'Positioning';

  @override
  String get power => 'Power';

  @override
  String get preview => 'Preview';

  @override
  String get profile => 'Profile';

  @override
  String get pointsShort => 'Pts';

  @override
  String get ratings => 'Ratings';

  @override
  String get recovery => 'Recovery';

  @override
  String get reject => 'Reject';

  @override
  String get rep => 'Rep';

  @override
  String get role => 'Role';

  @override
  String get roleRotation => 'Rotation';

  @override
  String get salary => 'Salary';

  @override
  String get settings => 'Settings';

  @override
  String get skills => 'Skills';

  @override
  String get squad => 'Squad';

  @override
  String get stamina => 'Stamina';

  @override
  String get standings => 'Standings';

  @override
  String get roleStarter => 'Starter';

  @override
  String get stats => 'Stats';

  @override
  String get store => 'Store';

  @override
  String get tackling => 'Tackling';

  @override
  String get team => 'Team';

  @override
  String get technical => 'Technical';

  @override
  String get technique => 'Technique';

  @override
  String get train => 'Train';

  @override
  String get vision => 'Vision';

  @override
  String get winsShort => 'W';

  @override
  String get week => 'Week';

  @override
  String get weekly => 'Weekly';

  @override
  String wWeek(int week) {
    return 'W$week';
  }

  @override
  String get years => 'years';

  @override
  String get activeContract => 'Active Contract';

  @override
  String get addDemoMessage => 'Add demo message';

  @override
  String get advanceWeek => 'Advance Week';

  @override
  String ageAge(int age) {
    return 'Age $age';
  }

  @override
  String get agentRelationship => 'Agent Relationship';

  @override
  String get bestRatings => 'Best Ratings';

  @override
  String get bodyStrength => 'Body Strength';

  @override
  String get investmentsSubtitle => 'Business portfolio';

  @override
  String get careerStatistics => 'Career statistics';

  @override
  String get careerStats => 'Career Stats';

  @override
  String get cashPacksAndPremium => 'Cash packs & Premium';

  @override
  String casinoLoss(double loss, double cash) {
    return 'Casino loss! You lost $loss. New cash: $cash';
  }

  @override
  String casinoWin(double delta, double cash) {
    return 'Casino win! You won $delta. New cash: $cash';
  }

  @override
  String get casinoAllIn => 'Casino — All In';

  @override
  String get casinoPlaceBet => 'Casino — Place Bet';

  @override
  String get claimFreeRewards => 'Claim free rewards';

  @override
  String get clearAll => 'Clear all';

  @override
  String get coachTrust => 'Coach Trust';

  @override
  String get contractDetails => 'Contract Details';

  @override
  String get profileSubtitle => 'Contract, wages & agent';

  @override
  String get contractWagesAgent => 'Contract, wages & agent';

  @override
  String get nationalStandingsSubtitle => 'Country rankings';

  @override
  String get countryRankings => 'Country rankings';

  @override
  String get currentBalance => 'Current Balance';

  @override
  String get endWeekApplyEconomy => 'End Week (Apply Economy)';

  @override
  String get enterAnyAmount => 'Enter any amount (up to your cash)';

  @override
  String get firstTouch => 'First Touch';

  @override
  String get footyStar => 'Footy Star';

  @override
  String get goToMatches => 'Go to Matches';

  @override
  String get hourlyRewards => 'Hourly Rewards';

  @override
  String get lifestyleSubtitle => 'Housing, cars, luxury items';

  @override
  String get housingCarsLuxuryItems => 'Housing, cars, luxury items';

  @override
  String get inboundTransfers => 'Inbound Transfers';

  @override
  String weekSummary(int earned, int spent, int delta, int cash) {
    return 'Income: \$$earned • Costs: \$$spent • Delta: $delta • Cash: \$$cash';
  }

  @override
  String get languageChanged => 'Language changed';

  @override
  String get leagueTable => 'League table';

  @override
  String get longPassing => 'Long Passing';

  @override
  String get longShots => 'Long Shots';

  @override
  String get loyaltyBonus => 'Loyalty Bonus';

  @override
  String lvLevel(int level) {
    return 'Lv $level';
  }

  @override
  String matchPlayedFriendly(Object home, Object away) {
    return 'Match played\n$home vs $away (friendly/unscheduled)';
  }

  @override
  String matchResult(int week, Object home, int hg, int ag, Object away) {
    return 'Match result — Week $week\n$home $hg - $ag $away';
  }

  @override
  String get matchScheduled => 'Match scheduled';

  @override
  String get myTeam => 'My Team';

  @override
  String get myTraining => 'My Training';

  @override
  String get nationalRankingsPlaceholder =>
      'National rankings will be shown here';

  @override
  String get nationalStandings => 'National Standings';

  @override
  String get nextMatch => 'Next match';

  @override
  String nextOpponent(Object opponent) {
    return 'Next opponent: $opponent';
  }

  @override
  String get noFixturesScheduled => 'No fixtures scheduled';

  @override
  String get noNotifications => 'No notifications yet';

  @override
  String get noStandingsYet =>
      'No standings yet. Play a match to populate the table.';

  @override
  String get perAssist => 'Per Assist';

  @override
  String get perGoal => 'Per Goal';

  @override
  String get performanceBonuses => 'Performance Bonuses';

  @override
  String get playAdvance => 'Play & Advance';

  @override
  String get playersStandings => 'Players Standings';

  @override
  String get previewSubtitle => 'Quick preview of common labels';

  @override
  String get realMoneyPurchases => 'Real Money Purchases';

  @override
  String get recoverySession => 'Recovery Session';

  @override
  String get releaseClause => 'Release Clause';

  @override
  String get requestSalaryRaise => 'Request Salary Raise';

  @override
  String get requestTransfer => 'Request Transfer';

  @override
  String get restAllSquad => 'Rest All Squad';

  @override
  String get resultPending => 'Result pending';

  @override
  String resultScore(int hg, int ag) {
    return 'Result: $hg - $ag';
  }

  @override
  String newSeason(int season) {
    return 'Season $season has started';
  }

  @override
  String get selectLanguage => 'Select language';

  @override
  String get shortPassing => 'Short Passing';

  @override
  String get shortShots => 'Short Shots';

  @override
  String get sprintSpeed => 'Sprint Speed';

  @override
  String get squadRested => 'Squad rested and recovered fatigue';

  @override
  String statusPercent(Object status, int value) {
    return 'Status: $status ($value%)';
  }

  @override
  String get teamOverview => 'Team overview';

  @override
  String get thisWeeksMatch => 'This week’s match';

  @override
  String get topAssists => 'Top Assists';

  @override
  String get topScorers => 'Top Scorers';

  @override
  String get playersStandingsSubtitle => 'Top scorers & assists';

  @override
  String get topScorersAssists => 'Top scorers & assists';

  @override
  String get inboundTransfersSubtitle => 'Transfer offers & negotiations';

  @override
  String get trophiesMilestones => 'Trophies & milestones';

  @override
  String get tryYourLuck => 'Try your luck';

  @override
  String get viewContract => 'View Contract';

  @override
  String get wagerAmount => 'Wager amount';

  @override
  String weekEnded(int week) {
    return 'Week $week ended';
  }

  @override
  String get weeklyCosts => 'Weekly Costs';

  @override
  String get weeklyIncome => 'Weekly Income';

  @override
  String skillTrained(Object player, Object skill, int level) {
    return '$player improved $skill to $level';
  }

  @override
  String xpProgress(int xp, int xpMax) {
    return '$xp / $xpMax XP';
  }
}
---
// FILE: lib/core/l10n/app_localizations_pt.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Portuguese (`pt`).
---
class AppLocalizationsPt extends AppLocalizations {
  AppLocalizationsPt([String locale = 'pt']) : super(locale);

  @override
  String get notifications_economy => 'Economia';

  @override
  String get notifications_general => 'Geral';

  @override
  String get notifications_match => 'Jogo';

  @override
  String get notifications_skills => 'Skills';

  @override
  String notifications_economy_week_summary(
    Object balance,
    Object costs,
    Object delta,
    Object revenue,
  ) {
    return 'Receitas: $revenue • Custos: $costs • Delta: $delta • Saldo: $balance';
  }

  @override
  String notifications_week_finished(Object week) {
    return 'Semana $week terminada';
  }

  @override
  String notifications_match_result(
    Object away,
    Object home,
    Object score,
    Object week,
  ) {
    return 'Resultado — Semana $week\n$home $score $away';
  }

  @override
  String notifications_skills_promoted_count(Object cost, Object count) {
    return 'Promovidas $count skills por $cost';
  }

  @override
  String get startDate => 'Data de início';

  @override
  String get endDate => 'Data de fim';

  @override
  String get cleanSheet => 'Baliza invicta';

  @override
  String get manOfTheMatch => 'Homem do jogo';

  @override
  String get wageRiseAfter20Games => 'Aumento salarial após 20 jogos';

  @override
  String afterNYears(int years) {
    return 'após $years anos';
  }

  @override
  String yearsDur(int count) {
    return '$count anos';
  }

  @override
  String get positionShort => '#';

  @override
  String get acceleration => 'Aceleração';

  @override
  String get achievements => 'Conquistas';

  @override
  String get actions => 'Ações';

  @override
  String get agility => 'Agilidade';

  @override
  String get annual => 'Anual';

  @override
  String get anticipation => 'Antecipação';

  @override
  String get assists => 'Assistências';

  @override
  String get bravery => 'Coragem';

  @override
  String get cancel => 'Cancelar';

  @override
  String get career => 'Carreira';

  @override
  String get cash => 'Saldo';

  @override
  String get casino => 'Casino';

  @override
  String get clauses => 'Cláusulas';

  @override
  String get composure => 'Calma';

  @override
  String get consistency => 'Consistência';

  @override
  String get costs => 'Custos';

  @override
  String get drawsShort => 'E';

  @override
  String get determination => 'Determinação';

  @override
  String get dribbling => 'Drible';

  @override
  String get duration => 'Duração';

  @override
  String get economy => 'Economia';

  @override
  String get english => 'Inglês';

  @override
  String get fatigue => 'Fadiga';

  @override
  String get finance => 'Finanças';

  @override
  String get finishing => 'Finalização';

  @override
  String get flexibility => 'Flexibilidade';

  @override
  String get form => 'Forma';

  @override
  String get goalsAgainstShort => 'GS';

  @override
  String get goalDifferenceShort => 'DG';

  @override
  String get general => 'Geral';

  @override
  String get goalsForShort => 'GM';

  @override
  String get goals => 'Golos';

  @override
  String get good => 'Bom';

  @override
  String get heading => 'Jogo Aéreo';

  @override
  String get home => 'Início';

  @override
  String get income => 'Receitas';

  @override
  String get investments => 'Investimentos';

  @override
  String get jumping => 'Impulsão';

  @override
  String get lossesShort => 'D';

  @override
  String get language => 'Idioma';

  @override
  String get leadership => 'Liderança';

  @override
  String get lifestyle => 'Estilo de Vida';

  @override
  String get marking => 'Marcação';

  @override
  String get matches => 'Jogos';

  @override
  String get mental => 'Mental';

  @override
  String get morale => 'Moral';

  @override
  String get negotiate => 'Negociar';

  @override
  String get newOffer => 'NOVO';

  @override
  String get notifications => 'Notificações';

  @override
  String get ok => 'OK';

  @override
  String get ovr => 'OVR';

  @override
  String get playedShort => 'J';

  @override
  String get physical => 'Físico';

  @override
  String get play => 'Jogar';

  @override
  String get portuguese => 'Português';

  @override
  String get positioning => 'Posicionamento';

  @override
  String get power => 'Potência';

  @override
  String get preview => 'Pré-visualização';

  @override
  String get profile => 'Perfil';

  @override
  String get pointsShort => 'Pts';

  @override
  String get ratings => 'Classificações';

  @override
  String get recovery => 'Recuperação';

  @override
  String get reject => 'Rejeitar';

  @override
  String get rep => 'Reputação';

  @override
  String get role => 'Papel';

  @override
  String get roleRotation => 'Rotação';

  @override
  String get salary => 'Salário';

  @override
  String get settings => 'Definições';

  @override
  String get skills => 'Skills';

  @override
  String get squad => 'Plantel';

  @override
  String get stamina => 'Resistência';

  @override
  String get standings => 'Classificação';

  @override
  String get roleStarter => 'Titular';

  @override
  String get stats => 'Estatísticas';

  @override
  String get store => 'Loja';

  @override
  String get tackling => 'Desarme';

  @override
  String get team => 'Equipa';

  @override
  String get technical => 'Técnico';

  @override
  String get technique => 'Técnica';

  @override
  String get train => 'Treinar';

  @override
  String get vision => 'Visão';

  @override
  String get winsShort => 'V';

  @override
  String get week => 'Semana';

  @override
  String get weekly => 'Semanal';

  @override
  String wWeek(int week) {
    return 'S$week';
  }

  @override
  String get years => 'anos';

  @override
  String get activeContract => 'Contrato Ativo';

  @override
  String get addDemoMessage => 'Adicionar mensagem de demo';

  @override
  String get advanceWeek => 'Avançar Semana';

  @override
  String ageAge(int age) {
    return 'Idade $age';
  }

  @override
  String get agentRelationship => 'Relação com o Agente';

  @override
  String get bestRatings => 'Melhores Classificações';

  @override
  String get bodyStrength => 'Força Física';

  @override
  String get investmentsSubtitle => 'Carteira de negócios';

  @override
  String get careerStatistics => 'Estatísticas de carreira';

  @override
  String get careerStats => 'Estatísticas de Carreira';

  @override
  String get cashPacksAndPremium => 'Pacotes de saldo e Premium';

  @override
  String casinoLoss(double loss, double cash) {
    return 'Casino: perdeste $loss. Novo saldo: $cash';
  }

  @override
  String casinoWin(double delta, double cash) {
    return 'Casino: ganhaste $delta. Novo saldo: $cash';
  }

  @override
  String get casinoAllIn => 'Casino — All In';

  @override
  String get casinoPlaceBet => 'Casino — Fazer Aposta';

  @override
  String get claimFreeRewards => 'Resgatar recompensas grátis';

  @override
  String get clearAll => 'Limpar tudo';

  @override
  String get coachTrust => 'Confiança do Treinador';

  @override
  String get contractDetails => 'Detalhes do Contrato';

  @override
  String get profileSubtitle => 'Contrato, salários e agente';

  @override
  String get contractWagesAgent => 'Contrato, salários e agente';

  @override
  String get nationalStandingsSubtitle => 'Classificação por países';

  @override
  String get countryRankings => 'Classificação por países';

  @override
  String get currentBalance => 'Saldo Atual';

  @override
  String get endWeekApplyEconomy => 'Fechar Semana (Aplicar Economia)';

  @override
  String get enterAnyAmount => 'Introduz um valor (até ao saldo)';

  @override
  String get firstTouch => 'Primeiro Toque';

  @override
  String get footyStar => 'Footy Star';

  @override
  String get goToMatches => 'Ir para Jogos';

  @override
  String get hourlyRewards => 'Recompensas Horárias';

  @override
  String get lifestyleSubtitle => 'Habitação, carros, artigos de luxo';

  @override
  String get housingCarsLuxuryItems => 'Habitação, carros, artigos de luxo';

  @override
  String get inboundTransfers => 'Transferências Recebidas';

  @override
  String weekSummary(int earned, int spent, int delta, int cash) {
    return 'Receitas: \$$earned • Custos: \$$spent • Delta: $delta • Saldo: \$$cash';
  }

  @override
  String get languageChanged => 'Idioma alterado';

  @override
  String get leagueTable => 'Tabela da Liga';

  @override
  String get longPassing => 'Passe Longo';

  @override
  String get longShots => 'Remate Longo';

  @override
  String get loyaltyBonus => 'Bónus de Lealdade';

  @override
  String lvLevel(int level) {
    return 'Nv $level';
  }

  @override
  String matchPlayedFriendly(Object home, Object away) {
    return 'Jogo realizado\n$home vs $away (amigável/fora de calendário)';
  }

  @override
  String matchResult(int week, Object home, int hg, int ag, Object away) {
    return 'Resultado — Semana $week\n$home $hg - $ag $away';
  }

  @override
  String get matchScheduled => 'Jogo agendado';

  @override
  String get myTeam => 'A Minha Equipa';

  @override
  String get myTraining => 'O Meu Treino';

  @override
  String get nationalRankingsPlaceholder =>
      'As classificações nacionais serão mostradas aqui';

  @override
  String get nationalStandings => 'Classificação Nacional';

  @override
  String get nextMatch => 'Próximo jogo';

  @override
  String nextOpponent(Object opponent) {
    return 'Próximo adversário: $opponent';
  }

  @override
  String get noFixturesScheduled => 'Sem jogos agendados';

  @override
  String get noNotifications => 'Sem notificações';

  @override
  String get noStandingsYet =>
      'Ainda não há classificação. Joga um jogo para preencher a tabela.';

  @override
  String get perAssist => 'Por Assistência';

  @override
  String get perGoal => 'Por Golo';

  @override
  String get performanceBonuses => 'Bónus de Desempenho';

  @override
  String get playAdvance => 'Jogar e Avançar';

  @override
  String get playersStandings => 'Classificação de Jogadores';

  @override
  String get previewSubtitle => 'Pré-visualização de etiquetas comuns';

  @override
  String get realMoneyPurchases => 'Compras com Dinheiro Real';

  @override
  String get recoverySession => 'Sessão de Recuperação';

  @override
  String get releaseClause => 'Cláusula de Rescisão';

  @override
  String get requestSalaryRaise => 'Pedir Aumento';

  @override
  String get requestTransfer => 'Pedir Transferência';

  @override
  String get restAllSquad => 'Descansar Plantel';

  @override
  String get resultPending => 'Resultado pendente';

  @override
  String resultScore(int hg, int ag) {
    return 'Resultado: $hg - $ag';
  }

  @override
  String newSeason(int season) {
    return 'Época $season começou';
  }

  @override
  String get selectLanguage => 'Selecionar idioma';

  @override
  String get shortPassing => 'Passe Curto';

  @override
  String get shortShots => 'Remate Curto';

  @override
  String get sprintSpeed => 'Velocidade de Sprint';

  @override
  String get squadRested => 'Plantel descansado e fadiga recuperada';

  @override
  String statusPercent(Object status, int value) {
    return 'Estado: $status ($value%)';
  }

  @override
  String get teamOverview => 'Visão geral da equipa';

  @override
  String get thisWeeksMatch => 'Jogo desta semana';

  @override
  String get topAssists => 'Melhores Assistentes';

  @override
  String get topScorers => 'Melhores Marcadores';

  @override
  String get playersStandingsSubtitle => 'Melhores marcadores e assistências';

  @override
  String get topScorersAssists => 'Melhores marcadores e assistências';

  @override
  String get inboundTransfersSubtitle => 'Propostas e negociações';

  @override
  String get trophiesMilestones => 'Troféus e marcos';

  @override
  String get tryYourLuck => 'Tenta a tua sorte';

  @override
  String get viewContract => 'Ver Contrato';

  @override
  String get wagerAmount => 'Valor da aposta';

  @override
  String weekEnded(int week) {
    return 'Semana $week terminada';
  }

  @override
  String get weeklyCosts => 'Custos Semanais';

  @override
  String get weeklyIncome => 'Receita Semanal';

  @override
  String skillTrained(Object player, Object skill, int level) {
    return '$player melhorou $skill para $level';
  }

  @override
  String xpProgress(int xp, int xpMax) {
    return '$xp / $xpMax XP';
  }
}
---
// FILE: lib/core/l10n/l10n_singleton.dart
import 'app_localizations.dart';

/// Holds the current AppLocalizations for places where BuildContext isn't available.
---
class L10n {
  static AppLocalizations? _current;

  /// Update the current localizations (call this whenever locale changes).
  static void set(AppLocalizations l10n) {
    _current = l10n;
  }

  /// Access the current localizations. Throws if not set.
  static AppLocalizations get i {
    final v = _current;
    if (v == null) {
      throw StateError(
        'L10n not initialized. Call L10n.set(AppLocalizations.of(context)!) early in your app.',
      );
    }
    return v;
  }
}
---
// FILE: lib/core/theme/app_theme.dart
import 'package:flutter/material.dart';
import 'palette.dart';
import 'typography.dart';

---
class AppTheme {
  AppTheme._();

  static ThemeData light() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: AppPalette.primary,
      brightness: Brightness.light,
    );

    return ThemeData(
      useMaterial3: true,
      colorScheme: colorScheme,
      scaffoldBackgroundColor: colorScheme.surface,
      textTheme: AppTypography.textTheme,

      appBarTheme: AppBarTheme(
        centerTitle: false,
        elevation: 0,
        backgroundColor: colorScheme.surface,
        foregroundColor: colorScheme.onSurface,
      ),

      // 🔧 AQUI: CardThemeData (não CardTheme)
      cardTheme: CardThemeData(
        elevation: 0,
        color: colorScheme.surface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: colorScheme.outline),
        ),
      ),

      inputDecorationTheme: InputDecorationTheme(
        border: const OutlineInputBorder(),
        filled: true,
        fillColor: colorScheme.surfaceVariant,
      ),

      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        ),
      ),

      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        ),
      ),

      navigationBarTheme: NavigationBarThemeData(
        elevation: 0,
        height: 64,
        backgroundColor: colorScheme.surface,
        surfaceTintColor: Colors.transparent,
        indicatorColor: colorScheme.primary.withOpacity(0.12),
        labelTextStyle: WidgetStateProperty.resolveWith(
              (states) => TextStyle(
            fontWeight: states.contains(WidgetState.selected) ? FontWeight.w600 : FontWeight.w500,
          ),
        ),
      ),
    );
  }

  static ThemeData dark() {
    final base = light();
    return base.copyWith(
      brightness: Brightness.dark,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppPalette.primary,
        brightness: Brightness.dark,
      ),
    );
  }
}
---
// FILE: lib/core/theme/icons.dart
import 'package:flutter/material.dart';

---
class AppIcons {
  AppIcons._();

  // Nav
  static const IconData home        = Icons.home_outlined;
  static const IconData homeFilled  = Icons.home;
  static const IconData matches     = Icons.sports_soccer_outlined;
  static const IconData matchesFilled= Icons.sports_soccer;
  static const IconData squad       = Icons.group_outlined;
  static const IconData squadFilled = Icons.group;
  static const IconData standings   = Icons.emoji_events_outlined;
  static const IconData standingsFilled = Icons.emoji_events;
  static const IconData casino      = Icons.casino_outlined;
  static const IconData casinoFilled= Icons.casino;
  static const IconData settings    = Icons.settings_outlined;
  static const IconData settingsFilled= Icons.settings;
  static const IconData profile     = Icons.person_outline;
  static const IconData profileFilled= Icons.person;
  static const IconData skills = Icons.star;
  static const IconData finance = Icons.account_balance;
  static const IconData general = Icons.apps;
  static const IconData economy = Icons.trending_up;
  static const IconData store = Icons.shopping_cart;


  // Actions
  static const IconData nextWeek    = Icons.skip_next;
  static const IconData train       = Icons.fitness_center;
  static const IconData recover     = Icons.health_and_safety;
  static const IconData notifyRead  = Icons.mark_email_read;
  static const IconData notifyUnread= Icons.mark_email_unread;
  static const IconData add         = Icons.add;
  static const IconData win         = Icons.trending_up;
  static const IconData transfer    = Icons.flight_takeoff;

  static const IconData share         = Icons.share;
  static const IconData verified      = Icons.verified;
  static const IconData assist        = Icons.assistant;
  static const IconData cleanSheet    = Icons.shield;
  static const IconData manOfTheMatch = Icons.star;
  static const IconData housing       = Icons.home;
  static const IconData business      = Icons.business;
  static const IconData chevronRight  = Icons.chevron_right;
  static const IconData payment       = Icons.payment;
  static const IconData hourly        = Icons.timer;
  static const IconData loss          = Icons.trending_down;
  static const IconData contract      = Icons.description;
}
---
// FILE: lib/core/theme/palette.dart
import 'package:flutter/material.dart';

---
class AppPalette {
  AppPalette._();

  // Brand
  static const primary = Color(0xFF3A86FF);
  static const secondary = Color(0xFFFFBE0B);

  // Neutrals
  static const neutral0  = Color(0xFF000000);
  static const neutral10 = Color(0xFF1C1C1E);
  static const neutral20 = Color(0xFF2C2C2E);
  static const neutral80 = Color(0xFFC7C7CC);
  static const neutral95 = Color(0xFFF2F2F7);
  static const neutral100= Color(0xFFFFFFFF);

  // Semantic
  static const success = Color(0xFF22C55E);
  static const warning = Color(0xFFF59E0B);
  static const danger  = Color(0xFFEF4444);

  // Surfaces
  static const surface  = neutral100;
  static const surfaceVariant = Color(0xFFF6F7F9);
}
---
// FILE: lib/core/theme/spacing.dart
---
class Gaps {
  Gaps._();
  static const xs = 4.0;
  static const sm = 8.0;
  static const md = 12.0;
  static const lg = 16.0;
  static const xl = 24.0;
  static const xxl = 32.0;
}

---
class Radii {
  Radii._();
  static const sm = 8.0;
  static const md = 12.0;
  static const lg = 16.0;
  static const pill = 999.0;
}
---
// FILE: lib/core/theme/typography.dart
import 'package:flutter/material.dart';

---
class AppTypography {
  AppTypography._();

  static TextTheme textTheme = const TextTheme(
    headlineSmall: TextStyle(fontWeight: FontWeight.w700),
    titleLarge:    TextStyle(fontWeight: FontWeight.w600),
    titleMedium:   TextStyle(fontWeight: FontWeight.w600),
    bodyMedium:    TextStyle(fontWeight: FontWeight.w400),
    labelLarge:    TextStyle(fontWeight: FontWeight.w600),
  );
}
---
// FILE: lib/core/utils/rng.dart
import 'dart:math';

final _rng = Random();

double rand() => _rng.nextDouble();     // 0..1
int randInt(int min, int max) => min + _rng.nextInt(max - min + 1);

// logistic helper for smooth probabilities
double logistic(double x) => 1 / (1 + exp(-x));
double exp(double x) => mathExp(x);
double mathExp(double x) => (x == 0) ? 1 : (x > 0 ? _expPos(x) : 1/_expPos(-x));
double _expPos(double x) {
  // fast approximation
  double sum = 1, term = 1;
  for (int n=1; n<20; n++) { term *= x/n; sum += term; }
  return sum;
}
---
// FILE: lib/data/services/business_service.dart
import '../../domain/models/business.dart';

---
class BusinessService {
  const BusinessService();

  bool meetsRequirements({
    required Business business,
    required int teamOvr,
    required double teamAvgReputation,
  }) {
    return teamOvr >= business.reqOvr && teamAvgReputation >= business.reqReputation;
  }

  int nextUpgradeCost(Business b) => b.costForNextLevel();

  int incomeDeltaIfUpgrade(Business b) {
    if (!b.canUpgrade) return 0;
    final nextLevel = b.level + 1;
    return b.incomeAt(nextLevel) - b.currentIncome();
  }
}
---
// FILE: lib/data/services/economy_service.dart
import 'dart:math';
import 'package:footy_star/domain/models/economy.dart';

/// Pure functions to transform Economy while keeping counters consistent.
/// Keep UI and controller logic thin by delegating cash/metrics math here.
---
class EconomyService {
  final _rng = Random();

  /// Apply the weekly delta (income - costs) to cash.
  /// Aggregations for season/all-time remain as-is.
  Economy applyWeekly(Economy e) {
    final delta = e.weeklyIncome - e.weeklyCosts;
    return e.copyWith(cash: e.cash + delta);
  }

  /// Casino bet: wagers up to available cash.
  /// Returns a new Economy with updated cash only; the controller updates metrics.
  Economy casino(Economy e, int wager) {
    final w = wager.clamp(0, e.cash);
    if (w == 0) return e;

    // ~48% win (earn +w), ~52% lose (spend w)
    final win = _rng.nextDouble() < 0.48;
    final nextCash = win ? (e.cash + w) : (e.cash - w);
    return e.copyWith(cash: nextCash);
  }

  /// Records a manual expense (e.g., purchase, fee).
  /// Clamps amount to not drive cash below zero.
  Economy recordExpense(Economy e, int amount) {
    final a = amount <= 0 ? 0 : amount;
    if (a == 0) return e;
    final spend = a.clamp(0, e.cash);
    return e.copyWith(
      cash: e.cash - spend,
      spentWeek: e.spentWeek + spend,
      spentSeason: e.spentSeason + spend,
      spentAllTime: e.spentAllTime + spend,
    );
  }

  /// Records a manual earning (e.g., prize, sponsorship).
  Economy recordEarning(Economy e, int amount) {
    final a = amount <= 0 ? 0 : amount;
    if (a == 0) return e;
    return e.copyWith(
      cash: e.cash + a,
      earnedSeason: e.earnedSeason + a,
      earnedAllTime: e.earnedAllTime + a,
    );
  }
}
---
// FILE: lib/data/services/match_service.dart
import '../../domain/models/team.dart';
import '../../core/utils/rng.dart';

---
class MatchResult {
  final int homeGoals;
  final int awayGoals;
  final double homeRepDelta;
  final double awayRepDelta;
  const MatchResult(this.homeGoals, this.awayGoals, this.homeRepDelta, this.awayRepDelta);
}

---
class MatchService {
  // Simple simulation with OVR, reputation and some RNG/momentum
  MatchResult play(Team home, Team away, {double repWeight = 0.2}) {
    final homeStrength = home.ovr.toDouble();
    final awayStrength = away.ovr.toDouble();

    final base = 1.2;
    final homeBias = 0.15; // casa
    final strengthDelta = (homeStrength - awayStrength) / 25.0; // escala
    final repDelta = repWeight * (avgReputation(home) - avgReputation(away)) / 100.0;

    final homeExpected = base + homeBias + strengthDelta + repDelta;
    final awayExpected = base - homeBias - strengthDelta - repDelta;

    final h = poissonSample(homeExpected.clamp(0.2, 4.5));
    final a = poissonSample(awayExpected.clamp(0.2, 4.5));

    // small but noticeable reputation deltas
    final homeRep = h > a ? 0.5 : (h < a ? -0.5 : 0.1);
    final awayRep = -homeRep;

    return MatchResult(h, a, homeRep, awayRep);
  }

  int poissonSample(double lambda) {
    // https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables
    // using Knuth's algorithm
    final L = mathExp(-lambda);
    int k = 0;
    double p = 1.0;
    do {
      k++;
      p *= rand();
    } while (p > L);
    return k - 1;
  }

  double avgReputation(Team t) {
    if (t.squad.isEmpty) return 0;
    final sum = t.squad.map((p)=>p.reputation).reduce((a,b)=>a+b);
    return sum / t.squad.length;
  }
}
---
// FILE: lib/data/services/skill_service.dart
import '../../domain/models/player.dart';
import '../../domain/models/skill.dart';

---
class SkillsService {
  // Add XP to a skill with banked progress
  Skill addXpToSkill(Skill skill, int xpAmount) {
    if (xpAmount <= 0) return skill;

    int remaining = xpAmount;
    int currentLevel = skill.level;
    int currentXp = skill.currentXp;
    int queuedLevels = skill.queuedLevels;
    int queuedXp = skill.queuedXp;

    // If skill is at max level, convert 50% to SP
    if (currentLevel + queuedLevels >= 100) {
      // Return skill unchanged, controller handles SP conversion
      return skill;
    }

    // Add to current level first
    if (queuedLevels == 0) {
      final cap = skill.xpCapForLevel(currentLevel);
      final space = cap - currentXp;

      if (remaining <= space) {
        // Fits in current level
        return skill.copyWith(currentXp: currentXp + remaining);
      } else {
        // Overflows to queued
        remaining -= space;
        queuedLevels = 1;
        queuedXp = 0;
        currentLevel = skill.level; // Don't actually level up yet
      }
    }

    // Add remaining XP to queued levels
    while (remaining > 0 && currentLevel + queuedLevels < 100) {
      final virtualLevel = currentLevel + queuedLevels;
      final cap = skill.xpCapForLevel(virtualLevel);
      final space = cap - queuedXp;

      if (remaining <= space) {
        queuedXp += remaining;
        remaining = 0;
      } else {
        remaining -= space;
        queuedLevels++;
        queuedXp = 0;
      }
    }

    return skill.copyWith(
      currentXp: queuedLevels == 0 ? currentXp + xpAmount : 0,
      queuedLevels: queuedLevels,
      queuedXp: queuedXp,
    );
  }

  // Promote a skill (pay cost, apply level)
  (Skill skill, bool success) promoteSkill(Skill skill, int availableCash) {
    if (skill.queuedLevels <= 0) {
      return (skill, false); // Nothing to promote
    }

    final cost = skill.promotionCost(skill.level);
    if (cost > availableCash) {
      return (skill, false); // Can't afford
    }

    // Apply one level
    final promoted = skill.copyWith(
      level: skill.level + 1,
      currentXp: skill.queuedLevels > 1 ? 0 : skill.queuedXp,
      queuedLevels: skill.queuedLevels - 1,
      queuedXp: skill.queuedLevels > 1 ? skill.queuedXp : 0,
    );

    return (promoted, true);
  }

  // Convert SP to XP (1 SP = 10 XP)
  int spToXp(int sp) => sp * 10;
}

---
// FILE: lib/data/services/training_service.dart
import '../../domain/models/player.dart';
import '../../domain/models/skill.dart';
import '../../domain/models/skills_catalog.dart';

---
class TrainingService {
  // Add XP to a skill with banked progress system
  Player trainSkill(Player p, String skillId, {int baseXp = 30}) {
    final skill = p.skills[skillId];
    if (skill == null) return p;

    // Reduz ganho para que SP seja a via principal
    final determinationBoost = 1 + 0.004 * (p.determination - 50); // ±20%
    final fatiguePenalty = (1 - 0.5 * p.fatigue).clamp(0.5, 1.0);
    final consistencyFactor = 1 + 0.002 * (p.consistency - 50); // ±10%

    // 40% do baseXp → treino é útil mas lento
    final xpGain = (baseXp * 0.4 * determinationBoost * fatiguePenalty * consistencyFactor).round();

    final updatedSkill = _addXpToSkill(skill, xpGain, p.sp);

    final newSkills = Map<String, Skill>.from(p.skills);
    newSkills[skillId] = updatedSkill;

    final newFatigue = (p.fatigue + 0.1).clamp(0.0, 1.0);
    final newForm = (p.form * 0.98 + 0.02).clamp(0.0, 1.0);

    return p.copyWith(
      skills: newSkills,
      fatigue: newFatigue,
      form: newForm,
    );
  }


  // Add XP to skill with banked progress
  Skill _addXpToSkill(Skill skill, int xpAmount, int playerSp) {
    if (xpAmount <= 0) return skill;

    // Se já atingiu o teto (nível real + bancados >= 100), ignora XP
    if (skill.level + skill.queuedLevels >= 100) {
      return skill;
    }

    var lvl = skill.level;
    var cur = skill.currentXp;
    var qLvls = skill.queuedLevels;
    var qXp = skill.queuedXp;
    var remaining = xpAmount;

    // 1) Preenche o nível atual primeiro (se ainda estamos nele)
    if (qLvls == 0) {
      final cap = skill.xpCapForLevel(lvl);
      final space = cap - cur;

      if (remaining < space) {
        return skill.copyWith(currentXp: cur + remaining);
      }

      // enche e transborda para fila
      remaining -= space;
      cur = 0;
      qLvls = 1;
      qXp = 0;
    }

    // 2) Enche níveis bancados consecutivos
    while (remaining > 0 && (lvl + qLvls) < 100) {
      final virtualLevel = lvl + qLvls;         // próximo nível “futuro”
      final cap = skill.xpCapForLevel(virtualLevel);
      final space = cap - qXp;

      if (remaining < space) {
        qXp += remaining;
        remaining = 0;
      } else {
        // enche este nível futuro e cria mais um slot
        remaining -= space;
        qLvls += 1;
        qXp = 0;
        // se acabámos de encher o 100, sai
        if (lvl + qLvls >= 100) break;
      }
    }

    return skill.copyWith(
      currentXp: qLvls == 0 ? (skill.currentXp + xpAmount) : 0,
      queuedLevels: qLvls,
      queuedXp: qXp,
    );
  }
  // Weekly passive training (coach-driven)
  Player passiveWeeklyTraining(Player p) {
    final weakSkills = _identifyWeakSkills(p);
    final roleSkills = _getRolePrioritySkills(p);

    var updatedPlayer = p;
    int skillsTrained = 0;

    // Muito pouco XP por semana para endurecer progressão
    for (final skillId in weakSkills) {
      if (skillsTrained >= 2) break;
      updatedPlayer = trainSkill(updatedPlayer, skillId, baseXp: 10); // 10 * 0.4 = 4 XP aprox
      skillsTrained++;
    }

    for (final skillId in roleSkills) {
      if (skillsTrained >= 4) break;
      if (!weakSkills.contains(skillId)) {
        updatedPlayer = trainSkill(updatedPlayer, skillId, baseXp: 8); // ~3 XP
        skillsTrained++;
      }
    }

    // SP semanal mínimo
    final spGain = 1;
    return updatedPlayer.copyWith(sp: updatedPlayer.sp + spGain);
  }

  // Identify weakest skills for the player's role
  List<String> _identifyWeakSkills(Player p) {
    final roleWeights = SkillsCatalog.roleWeights[p.role] ?? {};
    final weakSkills = <String>[];

    // Find skills that are below average for their importance
    roleWeights.forEach((skillId, weight) {
      final skill = p.skills[skillId];
      if (skill != null && skill.level < 50 && weight > 5.0) {
        weakSkills.add(skillId);
      }
    });

    // Sort by weakness (lowest level first)
    weakSkills.sort((a, b) {
      final skillA = p.skills[a]!;
      final skillB = p.skills[b]!;
      return skillA.level.compareTo(skillB.level);
    });

    return weakSkills.take(3).toList();
  }

  // Get priority skills for player's role
  List<String> _getRolePrioritySkills(Player p) {
    final roleWeights = SkillsCatalog.roleWeights[p.role] ?? {};
    final prioritySkills = <MapEntry<String, double>>[];

    roleWeights.forEach((skillId, weight) {
      if (weight > 8.0) { // High importance skills
        prioritySkills.add(MapEntry(skillId, weight));
      }
    });

    // Sort by importance
    prioritySkills.sort((a, b) => b.value.compareTo(a.value));

    return prioritySkills.map((e) => e.key).take(5).toList();
  }

  // Weekly recovery session
  Player rest(Player p) {
    final recoverySkill = p.skills['recovery'];
    final flexibilitySkill = p.skills['flexibility'];

    final recoveryBonus = recoverySkill != null ? 0.002 * recoverySkill.level : 0;
    final flexibilityBonus = flexibilitySkill != null ? 0.001 * flexibilitySkill.level : 0;

    final fatigueReduction = 0.2 + recoveryBonus + flexibilityBonus;
    final newFatigue = (p.fatigue - fatigueReduction).clamp(0.0, 1.0);
    final newForm = (p.form * 0.97 + 0.03).clamp(0.0, 1.0);

    return p.copyWith(fatigue: newFatigue, form: newForm);
  }

  // Convert SP to XP for a specific skill
  Player useSpOnSkill(Player p, String skillId, int spAmount) {
    if (spAmount <= 0 || spAmount > p.sp) return p;

    final skill = p.skills[skillId];
    if (skill == null) return p;

    const xpPerSp = 10;

    // Quanto falta para completar o nível atual
    final xpCap = skill.xpCapForLevel(skill.level);
    final missingXp = (xpCap - skill.currentXp).clamp(0, xpCap);

    final maxXpFromSp = spAmount * xpPerSp;
    final xpToAdd = maxXpFromSp.clamp(0, missingXp);
    final spUsed = (xpToAdd / xpPerSp).ceil();

    if (xpToAdd <= 0) return p;

    final updatedSkill = _addXpToSkill(skill, xpToAdd, p.sp - spUsed);

    final newSkills = Map<String, Skill>.from(p.skills);
    newSkills[skillId] = updatedSkill;

    return p.copyWith(
      skills: newSkills,
      sp: p.sp - spUsed,
    );
  }

  Player applyMinimalMatchXp(Player p, {int perSkill = 2}) {
    if (perSkill <= 0) return p;
    final newSkills = <String, Skill>{};
    p.skills.forEach((id, s) {
      newSkills[id] = _addXpToSkill(s, perSkill, p.sp);
    });
    return p.copyWith(skills: newSkills);
  }

  // Promote a single skill (pay cost and apply level)
  (Player, bool, int) promoteSkill(Player p, String skillId, int availableCash) {
    final skill = p.skills[skillId];
    if (skill == null || skill.queuedLevels <= 0) {
      return (p, false, 0);
    }

    final cost = skill.promotionCost(skill.level);
    if (cost > availableCash) {
      return (p, false, cost); // Can't afford
    }

    // Apply one level
    final promotedSkill = skill.copyWith(
      level: skill.level + 1,
      currentXp: skill.queuedLevels > 1 ? 0 : skill.queuedXp,
      queuedLevels: skill.queuedLevels - 1,
      queuedXp: skill.queuedLevels > 1 ? skill.queuedXp : 0,
    );

    final newSkills = Map<String, Skill>.from(p.skills);
    newSkills[skillId] = promotedSkill;

    return (p.copyWith(skills: newSkills), true, cost);
  }

  // Promote all queued levels for all skills
  (Player, int, List<String>) promoteAllSkills(Player p, int availableCash) {
    var updatedPlayer = p;
    int totalCost = 0;
    final promotedSkills = <String>[];
    var remainingCash = availableCash;

    // Try to promote all skills with queued levels
    for (final entry in p.skills.entries) {
      final skillId = entry.key;
      final skill = entry.value;

      while (skill.queuedLevels > 0 && remainingCash > 0) {
        final (newPlayer, success, cost) = promoteSkill(updatedPlayer, skillId, remainingCash);

        if (success) {
          updatedPlayer = newPlayer;
          totalCost += cost;
          remainingCash -= cost;
          if (!promotedSkills.contains(skillId)) {
            promotedSkills.add(skillId);
          }
        } else {
          break; // Can't afford this skill anymore
        }
      }
    }

    return (updatedPlayer, totalCost, promotedSkills);
  }
}

---
// FILE: lib/domain/models/app_message.dart
---
class AppMessage {
  final String id;
  final String title;
  final String body;
  final DateTime ts;
  final bool read;

  const AppMessage({
    required this.id,
    required this.title,
    required this.body,
    required this.ts,
    this.read = false,
  });

  AppMessage copyWith({String? title, String? body, DateTime? ts, bool? read}) {
    return AppMessage(
      id: id,
      title: title ?? this.title,
      body: body ?? this.body,
      ts: ts ?? this.ts,
      read: read ?? this.read,
    );
  }
}
---
// FILE: lib/domain/models/business.dart
import 'dart:math';

---
class Business {
  final String id;
  final String name;

  /// Current level (0 means not owned yet)
  final int level;

  /// Maximum level allowed
  final int maxLevel;

  /// Cost to buy at level 1 (or to upgrade from 0->1)
  final int baseCost;

  /// Multiplier applied per level for upgrade cost (>= 1.0)
  final double costMultiplier;

  /// Weekly income at level 1
  final int baseIncome;

  /// Increment of weekly income per level beyond level 1
  final int incomeStep;

  /// Requirements
  final int reqOvr;
  final double reqReputation; // team average reputation required

  const Business({
    required this.id,
    required this.name,
    required this.level,
    required this.maxLevel,
    required this.baseCost,
    required this.costMultiplier,
    required this.baseIncome,
    required this.incomeStep,
    required this.reqOvr,
    required this.reqReputation,
  });

  int incomeAt(int lvl) {
    if (lvl <= 0) return 0;
    final extra = max(0, lvl - 1);
    return baseIncome + extra * incomeStep;
  }

  int currentIncome() => incomeAt(level);

  int costForNextLevel() {
    if (level >= maxLevel) return 0;
    if (level <= 0) return baseCost;
    final v = baseCost * pow(costMultiplier, level);
    return v.round();
  }

  bool get canUpgrade => level < maxLevel;

  Business copyWith({
    String? id,
    String? name,
    int? level,
    int? maxLevel,
    int? baseCost,
    double? costMultiplier,
    int? baseIncome,
    int? incomeStep,
    int? reqOvr,
    double? reqReputation,
  }) {
    return Business(
      id: id ?? this.id,
      name: name ?? this.name,
      level: level ?? this.level,
      maxLevel: maxLevel ?? this.maxLevel,
      baseCost: baseCost ?? this.baseCost,
      costMultiplier: costMultiplier ?? this.costMultiplier,
      baseIncome: baseIncome ?? this.baseIncome,
      incomeStep: incomeStep ?? this.incomeStep,
      reqOvr: reqOvr ?? this.reqOvr,
      reqReputation: reqReputation ?? this.reqReputation,
    );
  }
}
---
// FILE: lib/domain/models/economy.dart
---
class Economy {
  final int cash;
  final int weeklyIncome;
  final int weeklyCosts;

  // Metrics
  final int spentWeek;      // manual expenses this week (casino, purchases, etc.)
  final int spentSeason;    // accumulated season expenses
  final int spentAllTime;   // accumulated lifetime expenses
  final int earnedSeason;   // accumulated season earnings
  final int earnedAllTime;  // accumulated lifetime earnings

  const Economy({
    required this.cash,
    required this.weeklyIncome,
    required this.weeklyCosts,
    this.spentWeek = 0,
    this.spentSeason = 0,
    this.spentAllTime = 0,
    this.earnedSeason = 0,
    this.earnedAllTime = 0,
  });

  Economy copyWith({
    int? cash,
    int? weeklyIncome,
    int? weeklyCosts,
    int? spentWeek,
    int? spentSeason,
    int? spentAllTime,
    int? earnedSeason,
    int? earnedAllTime,
  }) {
    return Economy(
      cash: cash ?? this.cash,
      weeklyIncome: weeklyIncome ?? this.weeklyIncome,
      weeklyCosts: weeklyCosts ?? this.weeklyCosts,
      spentWeek: spentWeek ?? this.spentWeek,
      spentSeason: spentSeason ?? this.spentSeason,
      spentAllTime: spentAllTime ?? this.spentAllTime,
      earnedSeason: earnedSeason ?? this.earnedSeason,
      earnedAllTime: earnedAllTime ?? this.earnedAllTime,
    );
  }
}
---
// FILE: lib/domain/models/event.dart
---
enum EventType { economic, sporting, personal }

---
class GameEvent {
  final String id;
  final EventType type;
  final String title;
  final String description;
  final void Function(_EventContext ctx) apply; //mutes state via context
  const GameEvent({required this.id, required this.type, required this.title, required this.description, required this.apply});
}

// reduced context to apply effects on the state
---
class _EventContext {
  int cashDelta = 0;
  double teamMoraleDelta = 0;
  double squadFatigueDelta = 0;
}
---
// FILE: lib/domain/models/fixture.dart
---
class Fixture {
  final int week;            // 1-based
  final String homeTeam;
  final String awayTeam;
  final bool played;
  final int? homeGoals;
  final int? awayGoals;

  const Fixture({
    required this.week,
    required this.homeTeam,
    required this.awayTeam,
    this.played = false,
    this.homeGoals,
    this.awayGoals,
  });

  bool get isMyTeamHome => false; // controller can ignore if not needed

  Fixture markPlayed(int hg, int ag) => Fixture(
    week: week,
    homeTeam: homeTeam,
    awayTeam: awayTeam,
    played: true,
    homeGoals: hg,
    awayGoals: ag,
  );
}
---
// FILE: lib/domain/models/league.dart
---
class League {
  final String id;
  final String name;
  final double multiplier; // dificulty/reward (0.85/1.00/1.15/1.30)
  const League({required this.id, required this.name, required this.multiplier});
}
---
// FILE: lib/domain/models/league_table.dart
---
class TableEntry {
  final String team;
  final int played;
  final int won;
  final int drawn;
  final int lost;
  final int gf;
  final int ga;

  const TableEntry({
    required this.team,
    required this.played,
    required this.won,
    required this.drawn,
    required this.lost,
    required this.gf,
    required this.ga,
  });

  int get gd => gf - ga;
  int get points => won * 3 + drawn;

  TableEntry applyResult({required int goalsFor, required int goalsAgainst}) {
    final np = played + 1;
    final ngf = gf + goalsFor;
    final nga = ga + goalsAgainst;
    if (goalsFor > goalsAgainst) {
      return TableEntry(team: team, played: np, won: won + 1, drawn: drawn, lost: lost, gf: ngf, ga: nga);
    } else if (goalsFor < goalsAgainst) {
      return TableEntry(team: team, played: np, won: won, drawn: drawn, lost: lost + 1, gf: ngf, ga: nga);
    } else {
      return TableEntry(team: team, played: np, won: won, drawn: drawn + 1, lost: lost, gf: ngf, ga: nga);
    }
  }

  static TableEntry empty(String team) => TableEntry(team: team, played: 0, won: 0, drawn: 0, lost: 0, gf: 0, ga: 0);
}

---
class LeagueTable {
  final Map<String, TableEntry> rows; // team -> entry

  const LeagueTable(this.rows);

  LeagueTable upsertTeam(String team) {
    if (rows.containsKey(team)) return this;
    final n = Map<String, TableEntry>.from(rows);
    n[team] = TableEntry.empty(team);
    return LeagueTable(n);
  }

  LeagueTable applyMatch({
    required String home,
    required String away,
    required int homeGoals,
    required int awayGoals,
  }) {
    final n = Map<String, TableEntry>.from(rows);
    final h = (n[home] ?? TableEntry.empty(home)).applyResult(goalsFor: homeGoals, goalsAgainst: awayGoals);
    final a = (n[away] ?? TableEntry.empty(away)).applyResult(goalsFor: awayGoals, goalsAgainst: homeGoals);
    n[home] = h;
    n[away] = a;
    return LeagueTable(n);
  }

  List<TableEntry> sorted() {
    final list = rows.values.toList();
    list.sort((a, b) {
      if (b.points != a.points) return b.points.compareTo(a.points);
      if (b.gd != a.gd) return b.gd.compareTo(a.gd);
      if (b.gf != a.gf) return b.gf.compareTo(a.gf);
      return a.team.compareTo(b.team);
    });
    return list;
  }
}
---
// FILE: lib/domain/models/played_match.dart
---
class PlayedMatch {
  final int week;
  final String homeName;
  final String awayName;
  final int homeGoals;
  final int awayGoals;

  const PlayedMatch({
    required this.week,
    required this.homeName,
    required this.awayName,
    required this.homeGoals,
    required this.awayGoals,
  });

  String get scoreline => '$homeGoals–$awayGoals';
  bool get homeWin => homeGoals > awayGoals;
  bool get awayWin => awayGoals > homeGoals;
  bool get draw => homeGoals == awayGoals;
}
---
// FILE: lib/domain/models/player.dart
import 'skill.dart';
import 'skills_catalog.dart';

---
class Player {
  final String id;
  final String name;
  final int age;
  final PlayerRole role;
  final Map<String, Skill> skills; // All 28 skills
  final double form;               // 0..1
  final double fatigue;            // 0..1
  final double reputation;         // 0..100
  final int sp;                    // Skill Points

  // Special attributes
  final double consistency;        // 0..100 (affects rating volatility)
  final double determination;      // 0..100 (affects training/selection)
  final double leadership;         // 0..100 (team bonus when captain)

  const Player({
    required this.id,
    required this.name,
    required this.age,
    required this.role,
    required this.skills,
    required this.form,
    required this.fatigue,
    required this.reputation,
    this.sp = 0,
    this.consistency = 50.0,
    this.determination = 50.0,
    this.leadership = 50.0,
  });

  // Calculate OVR based on role weights
  int get ovr {
    final weights = SkillsCatalog.roleWeights[role] ?? {};
    double weighted = 0.0;
    double totalWeight = 0.0;

    weights.forEach((skillId, weight) {
      final skill = skills[skillId];
      if (skill != null) {
        weighted += skill.level * weight;
        totalWeight += weight;
      }
    });

    if (totalWeight == 0) return 50;

    final base = weighted / totalWeight;
    final formAdjust = 0.9 + 0.2 * form;
    final fatigueAdjust = 1.0 - 0.2 * fatigue;

    return (base * formAdjust * fatigueAdjust).round().clamp(5, 100);
  }

  // Calculate confidence for match moments
  double get confidence {
    // Based on last matches ratings (placeholder)
    return form * 0.7 + (reputation / 100) * 0.3;
  }

  Player copyWith({
    String? name,
    int? age,
    PlayerRole? role,
    Map<String, Skill>? skills,
    double? form,
    double? fatigue,
    double? reputation,
    int? sp,
    double? consistency,
    double? determination,
    double? leadership,
  }) {
    return Player(
      id: id,
      name: name ?? this.name,
      age: age ?? this.age,
      role: role ?? this.role,
      skills: skills ?? this.skills,
      form: form ?? this.form,
      fatigue: fatigue ?? this.fatigue,
      reputation: reputation ?? this.reputation,
      sp: sp ?? this.sp,
      consistency: consistency ?? this.consistency,
      determination: determination ?? this.determination,
      leadership: leadership ?? this.leadership,
    );
  }
}

---
// FILE: lib/domain/models/skill.dart
import 'package:flutter/material.dart';
import '../../core/l10n/app_localizations.dart';

---
class Skill {
  final String id;
  final SkillCategory category;
  final int level; // Current level (5-100)
  final int currentXp; // XP for current level
  final int queuedLevels; // Banked levels ready to promote
  final int queuedXp; // XP for next queued level

  const Skill({
    required this.id,
    required this.category,
    this.level = 5,
    this.currentXp = 0,
    this.queuedLevels = 0,
    this.queuedXp = 0,
  });

  // Get localized name
  String getLocalizedName(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    switch (id) {
      case 'acceleration':
        return l10n.acceleration;
      case 'sprint_speed':
        return l10n.sprintSpeed;
      case 'agility':
        return l10n.agility;
      case 'body_strength':
        return l10n.bodyStrength;
      case 'jumping':
        return l10n.jumping;
      case 'stamina':
        return l10n.stamina;
      case 'power':
        return l10n.power;
      case 'flexibility':
        return l10n.flexibility;
      case 'recovery':
        return l10n.recovery;
      case 'first_touch':
        return l10n.firstTouch;
      case 'dribbling':
        return l10n.dribbling;
      case 'technique':
        return l10n.technique;
      case 'short_passing':
        return l10n.shortPassing;
      case 'long_passing':
        return l10n.longPassing;
      case 'vision':
        return l10n.vision;
      case 'finishing':
        return l10n.finishing;
      case 'short_shots':
        return l10n.shortShots;
      case 'long_shots':
        return l10n.longShots;
      case 'heading':
        return l10n.heading;
      case 'anticipation':
        return l10n.anticipation;
      case 'positioning':
        return l10n.positioning;
      case 'marking':
        return l10n.marking;
      case 'tackling':
        return l10n.tackling;
      case 'composure':
        return l10n.composure;
      case 'consistency':
        return l10n.consistency;
      case 'leadership':
        return l10n.leadership;
      case 'determination':
        return l10n.determination;
      case 'bravery':
        return l10n.bravery;
      default:
        return id;
    }
  }

  // Virtual level for display (level + queued)
  int get virtualLevel => (level + queuedLevels).clamp(5, 100);

  // XP needed for current level
  int xpCapForLevel(int lvl) {
    if (lvl <= 5) return 30;
    if (lvl >= 100) return 350;
    // Exponential curve from design
    final t = (lvl - 5) / 95.0;
    return (30 + (350 - 30) * t * t).round();
  }

  // Cost to promote this level
  int promotionCost(int lvl) {
    if (lvl <= 5) return 300;
    if (lvl >= 100) return 13000;
    // Exponential curve from design
    final t = (lvl - 5) / 95.0;
    return (300 + (13000 - 300) * t * t).round();
  }

  // Progress percentage for UI
  double get progressPercent {
    final cap = xpCapForLevel(level);
    return cap > 0 ? currentXp / cap : 0.0;
  }

  // Total cost to promote all queued levels
  int get totalPromotionCost {
    int total = 0;
    for (int i = 0; i < queuedLevels; i++) {
      total += promotionCost(level + i);
    }
    return total;
  }

  Skill copyWith({
    int? level,
    int? currentXp,
    int? queuedLevels,
    int? queuedXp,
  }) {
    return Skill(
      id: id,
      category: category,
      level: level ?? this.level,
      currentXp: currentXp ?? this.currentXp,
      queuedLevels: queuedLevels ?? this.queuedLevels,
      queuedXp: queuedXp ?? this.queuedXp,
    );
  }
}

---
extension SkillDisplay on Skill {
  /// Nível que a barra deve exibir (o próximo “virtual”, se houver fila)
  int get displayLevel => queuedLevels == 0 ? level : (level + queuedLevels);

  /// XP que a barra deve exibir (o do nível atual se sem fila, senão o do último nível virtual em progresso)
  int get displayXp => queuedLevels == 0 ? currentXp : queuedXp;

  /// Cap do nível exibido (atual ou virtual)
  int get displayXpCap => xpCapForLevel(displayLevel);

  /// Texto útil: "Lv 47 (+3 queued)"
  String get queuedBadge =>
      queuedLevels > 0 ? 'Lv $level (+$queuedLevels queued)' : 'Lv $level';
}

// lib/domain/models/skill.dart
---
extension SkillUi on Skill {
  /// Há níveis em fila?
  bool get isQueued => queuedLevels > 0;

  /// Progresso para a barra:
  /// - 100% quando há queued (barra cheia)
  /// - proporção normal quando não há queued
  double get progressForBar {
    final cap = xpCapForLevel(level);
    if (isQueued) return 1.0;
    if (cap <= 0) return 0.0;
    final p = currentXp / cap;
    return p.clamp(0.0, 1.0);
  }

  /// Texto do nível para mostrar ao lado da barra
  String get levelLabel =>
      isQueued ? 'Lv $level (+$queuedLevels queued)' : 'Lv $level';

  /// Texto auxiliar do XP (opcional no UI)
  String get xpHelperText {
    if (isQueued) return 'Ready to promote';
    final cap = xpCapForLevel(level);
    return '$currentXp / $cap XP';
  }
}

---
enum SkillCategory { physical, technical, mental }
---
// FILE: lib/domain/models/skills_catalog.dart
import 'skill.dart';

---
class SkillsCatalog {
  static const Map<String, Skill> all28Skills = {
    // Physical (9)
    'acceleration': Skill(
      id: 'acceleration',
      category: SkillCategory.physical,
    ),
    'sprint_speed': Skill(
      id: 'sprint_speed',
      category: SkillCategory.physical,
    ),
    'agility': Skill(
      id: 'agility',
      category: SkillCategory.physical,
    ),
    'body_strength': Skill(
      id: 'body_strength',
      category: SkillCategory.physical,
    ),
    'jumping': Skill(
      id: 'jumping',
      category: SkillCategory.physical,
    ),
    'stamina': Skill(
      id: 'stamina',
      category: SkillCategory.physical,
    ),
    'power': Skill(
      id: 'power',
      category: SkillCategory.physical,
    ),
    'flexibility': Skill(
      id: 'flexibility',
      category: SkillCategory.physical,
    ),
    'recovery': Skill(
      id: 'recovery',
      category: SkillCategory.physical,
    ),

    // Technical (10)
    'first_touch': Skill(
      id: 'first_touch',
      category: SkillCategory.technical,
    ),
    'dribbling': Skill(
      id: 'dribbling',
      category: SkillCategory.technical,
    ),
    'technique': Skill(
      id: 'technique',
      category: SkillCategory.technical,
    ),
    'short_passing': Skill(
      id: 'short_passing',
      category: SkillCategory.technical,
    ),
    'long_passing': Skill(
      id: 'long_passing',
      category: SkillCategory.technical,
    ),
    'vision': Skill(
      id: 'vision',
      category: SkillCategory.technical,
    ),
    'finishing': Skill(
      id: 'finishing',
      category: SkillCategory.technical,
    ),
    'short_shots': Skill(
      id: 'short_shots',
      category: SkillCategory.technical,
    ),
    'long_shots': Skill(
      id: 'long_shots',
      category: SkillCategory.technical,
    ),
    'heading': Skill(
      id: 'heading',
      category: SkillCategory.technical,
    ),

    // Mental/Defensive (9)
    'anticipation': Skill(
      id: 'anticipation',
      category: SkillCategory.mental,
    ),
    'positioning': Skill(
      id: 'positioning',
      category: SkillCategory.mental,
    ),
    'marking': Skill(
      id: 'marking',
      category: SkillCategory.mental,
    ),
    'tackling': Skill(
      id: 'tackling',
      category: SkillCategory.mental,
    ),
    'composure': Skill(
      id: 'composure',
      category: SkillCategory.mental,
    ),
    'consistency': Skill(
      id: 'consistency',
      category: SkillCategory.mental,
    ),
    'leadership': Skill(
      id: 'leadership',
      category: SkillCategory.mental,
    ),
    'determination': Skill(
      id: 'determination',
      category: SkillCategory.mental,
    ),
    'bravery': Skill(
      id: 'bravery',
      category: SkillCategory.mental,
    ),
  };

  // Role-based OVR weights (sum to 100)
  static const Map<PlayerRole, Map<String, double>> roleWeights = {
    PlayerRole.striker: {
      'finishing': 15.0,
      'short_shots': 6.0,
      'composure': 7.0,
      'positioning': 5.0,
      'dribbling': 9.0,
      'first_touch': 7.0,
      'acceleration': 7.0,
      'sprint_speed': 5.0,
      'agility': 5.0,
      'long_shots': 5.0,
      'power': 6.0,
      'heading': 6.0,
      'jumping': 3.0,
      'body_strength': 3.0,
      'short_passing': 3.0,
      'long_passing': 1.0,
      'vision': 1.0,
      'anticipation': 1.0,
      'tackling': 1.0,
      'stamina': 1.0,
    },
    PlayerRole.midfielder: {
      'short_passing': 11.0,
      'long_passing': 10.0,
      'vision': 10.0,
      'anticipation': 7.0,
      'positioning': 7.0,
      'composure': 6.0,
      'determination': 6.0,
      'dribbling': 6.0,
      'first_touch': 6.0,
      'stamina': 6.0,
      'acceleration': 4.0,
      'agility': 3.0,
      'sprint_speed': 3.0,
      'long_shots': 5.0,
      'finishing': 3.0,
      'body_strength': 2.0,
      'tackling': 2.0,
      'heading': 2.0,
      'jumping': 1.0,
      'technique': 2.0,
    },
    PlayerRole.defender: {
      'tackling': 15.0,
      'marking': 12.0,
      'positioning': 9.0,
      'anticipation': 8.0,
      'body_strength': 7.0,
      'heading': 7.0,
      'jumping': 5.0,
      'stamina': 5.0,
      'acceleration': 3.0,
      'agility': 3.0,
      'sprint_speed': 3.0,
      'determination': 4.0,
      'leadership': 3.0,
      'bravery': 4.0,
      'short_passing': 2.0,
      'first_touch': 1.0,
      'long_passing': 1.0,
      'composure': 1.0,
    },
  };
}

---
enum PlayerRole { striker, midfielder, defender }

---
// FILE: lib/domain/models/sp_rewards.dart
---
class SPRewards {
  // Match performance
  static const int goal = 3;
  static const int assist = 2;
  static const int cleanSheet = 2; // Para GK
  static const int motm = 5;       // Man of the match
  static const int winBonus = 1;

  // Training
  static const int weeklyBase = 1;
  static const int weeklyGoodForm = 1;    // Se form > 0.7
  static const int weeklyDetermination = 1; // Se determination > 70

  // Milestones
  static const int skillTo50 = 5;
  static const int skillTo70 = 10;
  static const int skillTo90 = 20;
  static const int skillTo100 = 50;
}

---
// FILE: lib/domain/models/team.dart
import 'player.dart';

---
class Team {
  final String id;
  final String name;
  final List<Player> squad;
  final double morale; // 0..1
  const Team({required this.id, required this.name, required this.squad, required this.morale});

  int get ovr {
    if (squad.isEmpty) return 0;
    final top11 = (squad..sort((a,b)=>b.ovr.compareTo(a.ovr))).take(11).toList();
    final avg = top11.map((p)=>p.ovr).reduce((a,b)=>a+b) / top11.length;
    final moraleAdj = 0.9 + 0.2 * morale; // 0.9..1.1
    return (avg * moraleAdj).round();
  }

  Team copyWith({List<Player>? squad, double? morale}) =>
      Team(id: id, name: name, squad: squad ?? this.squad, morale: morale ?? this.morale);
}
---
// FILE: lib/features/achievements/ui/achievements_screen.dart
import 'package:flutter/material.dart';
import '../../../core/l10n/app_localizations.dart';

---
class AchievementsScreen extends StatelessWidget {
  const AchievementsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.achievements)),
      body: Center(
        child: Text(l10n.trophiesMilestones),
      ),
    );
  }
}
---
// FILE: lib/features/casino/ui/casino_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:footy_star/app/providers/providers.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

---
class CasinoScreen extends ConsumerStatefulWidget {
  const CasinoScreen({super.key});
  @override
  ConsumerState<CasinoScreen> createState() => _CasinoScreenState();
}

---
class _CasinoScreenState extends ConsumerState<CasinoScreen> {
  final _ctrl = TextEditingController(text: '100');

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.watch(gameControllerProvider);
    final game = ref.read(gameControllerProvider.notifier);
    final canBet = state.economy.cash > 0;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.casino)),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('${l10n.cash}: \$${state.economy.cash}'),
            const SizedBox(height: 12),
            TextField(
              controller: _ctrl,
              keyboardType: TextInputType.number,
              decoration: InputDecoration(
                labelText: l10n.wagerAmount,
                hintText: l10n.enterAnyAmount,
                border: const OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 12),
            FilledButton(
              onPressed: !canBet
                  ? null
                  : () {
                final amount = int.tryParse(_ctrl.text.trim()) ?? 0;
                final res = game.casinoWagerWithResult(amount);
                final txt = res.win
                    ? l10n.casinoWin(
                  res.delta.abs().toDouble(),
                  state.economy.cash.toDouble(),
                )
                    : l10n.casinoLoss(
                  res.delta.abs().toDouble(),
                  state.economy.cash.toDouble(),
                );
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text(txt)),
                );
              },
              child: Text(l10n.casinoPlaceBet),
            ),
            const SizedBox(height: 8),
            FilledButton(
              onPressed: !canBet
                  ? null
                  : () {
                final res = game.casinoWagerWithResult(state.economy.cash);
                final txt = res.win
                    ? l10n.casinoWin(
                  res.delta.abs().toDouble(),
                  state.economy.cash.toDouble(),
                )
                    : l10n.casinoLoss(
                  res.delta.abs().toDouble(),
                  state.economy.cash.toDouble(),
                );
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text(txt)),
                );
              },
              child: Text(l10n.casinoAllIn),
            ),
          ],
        ),
      ),
    );
  }
}
---
// FILE: lib/features/contracts/ui/contract_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../app/providers/providers.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';
import 'package:footy_star/core/theme/icons.dart';

---
class ContractScreen extends ConsumerWidget {
  const ContractScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.watch(gameControllerProvider);
    final economy = state.economy;

    final weekly = economy.weeklyIncome;
    final annual = weekly * 52;

    // Contract details (placeholder for now)
    const duration = 2; // years
    const startDate = '01/07/2024';
    const endDate = '30/06/2026';
    // role value em l10n (em vez de string fixa)
    final role = l10n.roleRotation;

    // Bonuses
    const bonusGoal = 500;
    const bonusAssist = 250;
    const bonusCleanSheet = 300;
    const bonusMotm = 400;

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.contractDetails),
        actions: [
          IconButton(
            icon: const Icon(AppIcons.share),
            onPressed: () {
              // Share contract
            },
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // Contract Header
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(
                        Icons.verified,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        l10n.activeContract,
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  _ContractRow(label: l10n.team, value: state.myTeam.name),
                  _ContractRow(label: l10n.duration, value: l10n.yearsDur(duration)),
                  _ContractRow(label: l10n.startDate, value: startDate),
                  _ContractRow(label: l10n.endDate, value: endDate),
                  _ContractRow(label: l10n.role, value: role),
                ],
              ),
            ),
          ),

          const SizedBox(height: 16),

          // Salary Section
          Text(l10n.salary, style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),

          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(l10n.weekly),
                      Text(
                        '\$$weekly',
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ],
                  ),
                  const Divider(),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(l10n.annual),
                      Text(
                        '\$$annual',
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),

          const SizedBox(height: 16),

          // Bonuses Section
          Text(l10n.performanceBonuses, style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),

          Card(
            child: Column(
              children: [
                _BonusTile(label: l10n.perGoal, amount: bonusGoal, icon: Icons.sports_soccer),
                const Divider(height: 1),
                _BonusTile(label: l10n.perAssist, amount: bonusAssist, icon: Icons.assistant),
                const Divider(height: 1),
                _BonusTile(label: l10n.cleanSheet, amount: bonusCleanSheet, icon: Icons.shield),
                const Divider(height: 1),
                _BonusTile(label: l10n.manOfTheMatch, amount: bonusMotm, icon: Icons.star),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Clauses Section
          Text(l10n.clauses, style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),

          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _ClauseItem(label: l10n.releaseClause, value: '\$5,000,000'),
                  const SizedBox(height: 8),
                  _ClauseItem(label: l10n.wageRiseAfter20Games, value: '+10%'),
                  const SizedBox(height: 8),
                  _ClauseItem(
                    label: l10n.loyaltyBonus,
                    value: '\$50,000 ${l10n.afterNYears(2)}',
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

---
class _ContractRow extends StatelessWidget {
  final String label;
  final String value;

  const _ContractRow({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label),
          Text(value, style: const TextStyle(fontWeight: FontWeight.w600)),
        ],
      ),
    );
  }
}

---
class _BonusTile extends StatelessWidget {
  final String label;
  final int amount;
  final IconData icon;

  const _BonusTile({
    required this.label,
    required this.amount,
    required this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: Icon(icon, size: 20),
      title: Text(label),
      trailing: Text(
        '\$$amount',
        style: Theme.of(context).textTheme.titleMedium,
      ),
    );
  }
}

---
class _ClauseItem extends StatelessWidget {
  final String label;
  final String value;

  const _ClauseItem({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label),
        Text(
          value,
          style: TextStyle(
            fontWeight: FontWeight.w600,
            color: Theme.of(context).colorScheme.primary,
          ),
        ),
      ],
    );
  }
}
---
// FILE: lib/features/dashboard/ui/dashboard_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';
import '../../../app/providers/providers.dart';

---
class DashboardScreen extends ConsumerWidget {
  const DashboardScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final s = ref.watch(gameControllerProvider);

    return Scaffold(
      appBar: AppBar(title: Text(l10n.footyStar)),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${s.league.name} — ${l10n.week} ${s.week}',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 8),
            Text(
              '${l10n.teamOverview}: ${s.myTeam.name}  |  ${l10n.ovr} ${s.myTeam.ovr}  |  ${l10n.morale} ${(s.myTeam.morale * 100).round()}%',
            ),
            const SizedBox(height: 8),
            Text(
              '${l10n.cash}: \$${s.economy.cash}  |  ${l10n.income} ${s.economy.weeklyIncome}  |  ${l10n.costs} ${s.economy.weeklyCosts}',
            ),
            const Spacer(),
            FilledButton(
              onPressed: () =>
                  ref.read(gameControllerProvider.notifier).endOfWeekEconomy(),
              child: Text(l10n.endWeekApplyEconomy),
            ),
          ],
        ),
      ),
    );
  }
}
---
// FILE: lib/features/finance/ui/economy_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';
import '../../../app/providers/providers.dart';
import '../../casino/ui/casino_screen.dart';

---
class EconomyScreen extends ConsumerWidget {
  const EconomyScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.watch(gameControllerProvider);
    final eco = state.economy;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.economy)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // Current Balance
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Text(
                    l10n.currentBalance,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    '\$${eco.cash}',
                    style: Theme.of(context).textTheme.headlineLarge,
                  ),
                ],
              ),
            ),
          ),

          const SizedBox(height: 16),

          // Weekly Overview
          Row(
            children: [
              Expanded(
                child: _MetricCard(
                  title: l10n.weeklyIncome,
                  value: '\$${eco.weeklyIncome}',
                  icon: Icons.trending_up,
                  color: Colors.green,
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: _MetricCard(
                  title: l10n.weeklyCosts,
                  value: '\$${eco.weeklyCosts}',
                  icon: Icons.trending_down,
                  color: Colors.red,
                ),
              ),
            ],
          ),

          const SizedBox(height: 16),

          // Sub-sections
          _SectionCard(
            title: l10n.lifestyle,
            subtitle: l10n.lifestyleSubtitle,
            icon: Icons.home,
            onTap: () {
              // Navigate to Lifestyle screen
            },
          ),

          _SectionCard(
            title: l10n.investments,
            subtitle: l10n.investmentsSubtitle,
            icon: Icons.business,
            onTap: () {
              // Navigate to Investments screen
            },
          ),

          _SectionCard(
            title: l10n.casino,
            subtitle: l10n.tryYourLuck,
            icon: Icons.casino,
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const CasinoScreen()),
              );
            },
          ),
        ],
      ),
    );
  }
}

---
class _MetricCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color color;

  const _MetricCard({
    required this.title,
    required this.value,
    required this.icon,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          children: [
            Icon(icon, color: color),
            const SizedBox(height: 8),
            Text(value, style: Theme.of(context).textTheme.titleLarge),
            Text(title, style: Theme.of(context).textTheme.bodySmall),
          ],
        ),
      ),
    );
  }
}

---
class _SectionCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final VoidCallback onTap;

  const _SectionCard({
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: Icon(icon, size: 32),
        title: Text(title),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
      ),
    );
  }
}
---
// FILE: lib/features/finance/ui/finance_hub_screen.dart
// features/finance/ui/finance_hub_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

---
class FinanceHubScreen extends ConsumerWidget {
  const FinanceHubScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.finance)),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.construction,
              size: 64,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(height: 16),
            Text(
              'Finance Hub - Coming Soon',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            Text(
              'Weekly statements, income sources,\nexpenses and budget planning',
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodyLarge,
            ),
          ],
        ),
      ),
    );
  }
}

---
// FILE: lib/features/general/ui/general_hub_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

import '../../achievements/ui/achievements_screen.dart';
import '../../profile/ui/profile_screen.dart';
import '../../squad/ui/squad_screen.dart';
import '../../standings/ui/national_standings_screen.dart';
import '../../standings/ui/player_standings_screen.dart';
import '../../standings/ui/standings_screen.dart';
import '../../stats/ui/stats_screen.dart';
import '../../transfers/ui/transfers_screen.dart';

---
class GeneralHubScreen extends ConsumerWidget {
  const GeneralHubScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.general)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _HubCard(
            title: l10n.profile,
            subtitle: l10n.profileSubtitle,
            icon: Icons.person,
            onTap: () => _navigateTo(context, const ProfileScreen()),
          ),
          _HubCard(
            title: l10n.squad,
            subtitle: l10n.teamOverview,
            icon: Icons.group,
            onTap: () => _navigateTo(context, const SquadScreen()),
          ),
          _HubCard(
            title: l10n.standings,
            subtitle: l10n.leagueTable,
            icon: Icons.emoji_events,
            onTap: () => _navigateTo(context, const StandingsScreen()),
          ),
          _HubCard(
            title: l10n.inboundTransfers,
            subtitle: l10n.inboundTransfersSubtitle,
            icon: Icons.swap_horiz,
            onTap: () => _navigateTo(context, const TransfersScreen()),
          ),
          _HubCard(
            title: l10n.nationalStandings,
            subtitle: l10n.nationalStandingsSubtitle,
            icon: Icons.flag,
            onTap: () => _navigateTo(context, const NationalStandingsScreen()),
          ),
          _HubCard(
            title: l10n.playersStandings,
            subtitle: l10n.playersStandingsSubtitle,
            icon: Icons.sports_soccer,
            onTap: () => _navigateTo(context, const PlayersStandingsScreen()),
          ),
          _HubCard(
            title: l10n.achievements,
            subtitle: l10n.trophiesMilestones,
            icon: Icons.military_tech,
            onTap: () => _navigateTo(context, const AchievementsScreen()),
          ),
          _HubCard(
            title: l10n.stats,
            subtitle: l10n.careerStatistics,
            icon: Icons.bar_chart,
            onTap: () => _navigateTo(context, const StatsScreen()),
          ),
        ],
      ),
    );
  }

  void _navigateTo(BuildContext context, Widget screen) {
    Navigator.push(context, MaterialPageRoute(builder: (_) => screen));
  }
}

---
class _HubCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final VoidCallback onTap;

  const _HubCard({
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: Icon(icon, size: 32),
        title: Text(title),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
      ),
    );
  }
}
---
// FILE: lib/features/home/ui/home_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../app/providers/providers.dart';
import '../../../domain/models/app_message.dart';
import '../../match/ui/match_screen.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

---
class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final s = ref.watch(gameControllerProvider);
    final messages = ref.watch(notificationsProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.home),
        actions: [
          IconButton(
            tooltip: l10n.advanceWeek,
            icon: const Icon(Icons.skip_next),
            onPressed: () async {
              await ref.read(gameControllerProvider.notifier).advanceWeek();
            },
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // Team info
          Card(
            child: ListTile(
              title: Text(s.myTeam.name),
              subtitle: Text('${s.league.name} • ${l10n.week} ${s.week}'),
              trailing: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(l10n.cash),
                  Text('\$${s.economy.cash}',
                      style: Theme.of(context).textTheme.titleMedium),
                ],
              ),
            ),
          ),
          const SizedBox(height: 12),

          // Quick stats
          Row(
            children: [
              Expanded(
                child: _StatChip(
                  label: l10n.weeklyIncome,
                  value: '\$${s.economy.weeklyIncome}',
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: _StatChip(
                  label: l10n.weeklyCosts,
                  value: '\$${s.economy.weeklyCosts}',
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),

          // Next match card
          Card(
            child: ListTile(
              leading: const Icon(Icons.sports_soccer),
              title: Text(l10n.nextMatch),
              subtitle: Text(
                '${l10n.week} ${s.week}: ${s.myTeam.name} vs ${s.opponent.name}',
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Notifications header + actions
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(l10n.notifications,
                  style: Theme.of(context).textTheme.titleMedium),
              TextButton(
                onPressed: () {
                  ref.read(notificationsProvider.notifier).clearAll();
                },
                child: Text(l10n.clearAll),
              ),
            ],
          ),
          const SizedBox(height: 8),

          // Notifications list
          if (messages.isEmpty)
            Center(child: Text(l10n.noNotifications))
          else
            ...messages.map((m) => _MessageTile(msg: m)).toList(),

          const SizedBox(height: 24),

          // Demo actions
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              OutlinedButton(
                onPressed: () {
                  ref.read(notificationsProvider.notifier).push(
                    AppMessage(
                      id: DateTime.now()
                          .microsecondsSinceEpoch
                          .toString(),
                      title: l10n.matchScheduled,
                      body: l10n.nextOpponent(s.opponent.name),
                      ts: DateTime.now(),
                    ),
                  );
                },
                child: Text(l10n.addDemoMessage),
              ),
              OutlinedButton(
                onPressed: () {
                  Navigator.of(context).push(
                    MaterialPageRoute(
                        builder: (_) => const MatchScreen()),
                  );
                },
                child: Text(l10n.goToMatches),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

---
class _StatChip extends StatelessWidget {
  final String label;
  final String value;
  const _StatChip({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(label),
          const SizedBox(height: 4),
          Text(value, style: Theme.of(context).textTheme.titleMedium),
        ],
      ),
    );
  }
}

---
class _MessageTile extends ConsumerWidget {
  final AppMessage msg;
  const _MessageTile({required this.msg});

  String _localizedTitle(AppLocalizations l10n, String raw) {
    switch (raw) {
      case 'Economy':  return l10n.economy;
      case 'General':  return l10n.general;
      case 'Match':    return l10n.matches;   // chave existente é 'matches'
      case 'Skills':   return l10n.skills;
      case 'Training': return l10n.myTraining; // usa a que tens no l10n
      case 'Casino':   return l10n.casino;
      case 'Agent':    return l10n.general;   // fallback até criares 'agent' no .arb
      case 'Coach':    return l10n.general;   // idem (ou cria chave própria)
      default:         return raw;            // caso apareça algo novo
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final isRead = msg.read;

    return Card(
      child: ListTile(
        title: Text(
          _localizedTitle(l10n, msg.title),
          style: TextStyle(
            fontWeight: isRead ? FontWeight.normal : FontWeight.w600,
          ),
        ),
        subtitle: Text(msg.body),
        trailing: Icon(isRead ? Icons.mark_email_read : Icons.mark_email_unread),
        // ... resto igual
      ),
    );
  }
}

---
// FILE: lib/features/match/models/match_moment.dart
import '../../../domain/models/player.dart';

---
enum MomentType {
  kickOff, halfTime, fullTime,
  buildUp, chance, shotOnTarget, shotOffTarget,
  save, goal, foul, yellow, red, injury,
}

---
class MatchMoment {
  final int minute;               // 1..90
  final String teamId;            // who the moment belongs to (can be "")
  final MomentType type;
  final String key;               // i18n key (debug-friendly)
  final Map<String, dynamic> args;// extra data (att, assist, xg, etc.)

  const MatchMoment({
    required this.minute,
    required this.teamId,
    required this.type,
    required this.key,
    this.args = const {},
  });
}

---
class MatchScore {
  final int home, away;
  const MatchScore(this.home, this.away);
}

---
class PlayerStats {
  int goals = 0, assists = 0, shots = 0, shotsOnTarget = 0, yellow = 0, red = 0;
  int spEarned = 0; // SP earnt on game
}

---
class MatchSim {
  final List<MatchMoment> moments;
  final MatchScore score;
  final Map<String, PlayerStats> playerStats;
  const MatchSim({required this.moments, required this.score, required this.playerStats});
}
---
// FILE: lib/features/match/services/match_moments_engine.dart
import 'dart:math';
import '../../../domain/models/team.dart';
import '../../../domain/models/player.dart';
import '../models/match_moment.dart';

/// Simple "match moments" engine (90' running time).
/// - generates attacks per minute (approx. Poisson)
/// - resolves chance quality -> xG -> outcome
/// - updates per-player stats
---
class MatchMomentsEngine {
  final Random _rng;

  MatchMomentsEngine([Random? rng]) : _rng = rng ?? Random();

  MatchSim simulate({required Team home, required Team away}) {
    final moments = <MatchMoment>[];
    final stats = <String, PlayerStats>{};
    int homeGoals = 0, awayGoals = 0;

    // kick-off
    moments.add(
      MatchMoment(
        minute: 1,
        teamId: home.id,
        type: MomentType.kickOff,
        key: 'match_kickoff',
        args: {'home': home.name, 'away': away.name},
      ),
    );

    // simple global ratings
    final atkHome = _attackRating(home);
    final defHome = _defenseRating(home);
    final atkAway = _attackRating(away);
    final defAway = _defenseRating(away);

    // expected intensity (events per minute)
    final lambdaHome = max(0.8, atkHome / (defAway + 1)) * 0.9; // events/min
    final lambdaAway = max(0.8, atkAway / (defHome + 1)) * 0.9;

    // helpers
    Player pickAttacker(Team t) =>
        _weightedPick(t.squad, (p) => _attackerWeight(p));
    Player pickAssistant(Team t, Player exclude) => _weightedPick(
      t.squad.where((x) => x.id != exclude.id).toList(),
      (p) => _assistantWeight(p),
    );
    Player pickDefender(Team t) =>
        _weightedPick(t.squad, (p) => _defenderWeight(p));
    Player pickGK(Team t) => t.squad.firstWhere(
      (p) => p.role.name.toLowerCase().contains('gk'),
      orElse: () => _fallbackGK(t),
    );

    final gkHome = pickGK(home);
    final gkAway = pickGK(away);

    // 1..90 loop
    for (int m = 1; m <= 90; m++) {
      // half-time marker
      if (m == 46) {
        moments.add(
          MatchMoment(
            minute: m,
            teamId: '',
            type: MomentType.halfTime,
            key: 'match_halftime',
          ),
        );
      }

      // decide whether home attacks
      final homeAttacks = _bernoulli(lambdaHome);
      if (homeAttacks) {
        final res = _resolveAttack(
          minute: m,
          team: home,
          opponent: away,
          gkOpponent: gkAway,
          pickAttacker: pickAttacker,
          pickAssistant: pickAssistant,
          pickDefender: pickDefender,
          stats: stats,
        );
        moments.addAll(res.moments);
        if (res.goal) homeGoals++;
      }

      // decide whether away attacks
      final awayAttacks = _bernoulli(lambdaAway);
      if (awayAttacks) {
        final res = _resolveAttack(
          minute: m,
          team: away,
          opponent: home,
          gkOpponent: gkHome,
          pickAttacker: pickAttacker,
          pickAssistant: pickAssistant,
          pickDefender: pickDefender,
          stats: stats,
        );
        moments.addAll(res.moments);
        if (res.goal) awayGoals++;
      }

      // occasional disciplinary events
      if (_rng.nextDouble() < 0.03) {
        final foulTeam = _rng.nextBool() ? home : away;
        final offender = _weightedPick(
          foulTeam.squad,
          (p) => _disciplineWeight(p),
        );
        final roll = _rng.nextDouble();
        if (roll < 0.85) {
          _inc(stats, offender.id).yellow++;
          moments.add(
            MatchMoment(
              minute: m,
              teamId: foulTeam.id,
              type: MomentType.yellow,
              key: 'match_yellow',
              args: {'player': offender.name},
            ),
          );
        } else {
          _inc(stats, offender.id).red++;
          moments.add(
            MatchMoment(
              minute: m,
              teamId: foulTeam.id,
              type: MomentType.red,
              key: 'match_red',
              args: {'player': offender.name},
            ),
          );
        }
      }
    }

    // full-time
    moments.add(
      MatchMoment(
        minute: 90,
        teamId: '',
        type: MomentType.fullTime,
        key: 'match_fulltime',
      ),
    );

    return MatchSim(
      moments: moments..sort((a, b) => a.minute.compareTo(b.minute)),
      score: MatchScore(homeGoals, awayGoals),
      playerStats: stats,
    );
  }

  // ---------- internals ----------

  // One "event per minute" ~ Bernoulli with p = clamp(lambda/2.5, ...).
  // Here we already receive λ normalized per minute (above).
  bool _bernoulli(double lambdaPerMin) {
    final p = min(
      0.9,
      lambdaPerMin / 2.5,
    ); // controls intensity; ~0.3..0.4 => lively match
    return _rng.nextDouble() < p;
  }

  // Resolve a single attack: build-up -> chance -> shot -> goal/save/miss
  _AttackResult _resolveAttack({
    required int minute,
    required Team team,
    required Team opponent,
    required Player gkOpponent,
    required Player Function(Team) pickAttacker,
    required Player Function(Team, Player) pickAssistant,
    required Player Function(Team) pickDefender,
    required Map<String, PlayerStats> stats,
  }) {
    final moments = <MatchMoment>[];

    // build-up
    moments.add(
      MatchMoment(
        minute: minute,
        teamId: team.id,
        type: MomentType.buildUp,
        key: 'match_buildup',
      ),
    );

    // who attacks / assists / defends
    final att = pickAttacker(team);
    final maybeAssist = pickAssistant(team, att);
    final def = pickDefender(opponent);

    // offensive vs defensive quality
    final off = _offensiveScore(att, maybeAssist);
    final dea = _defensiveScore(def, gkOpponent);

    // base xG
    final raw = (off - dea); // can be negative
    double xg = 0.03 + 0.004 * raw; // ~ 0.03..0.45
    xg = xg.clamp(0.02, 0.55);

    // create the "chance"
    moments.add(
      MatchMoment(
        minute: minute,
        teamId: team.id,
        type: MomentType.chance,
        key: 'match_chance',
        args: {
          'att': att.name,
          'ast': maybeAssist.name,
          'xg': xg.toStringAsFixed(2),
        },
      ),
    );

    // shot
    _inc(stats, att.id).shots++;
    final onTargetProb =
        0.45 +
        0.003 * (_skill(att, 'finishing') + _skill(att, 'composure') - 100);
    final onTarget = _rng.nextDouble() < onTargetProb.clamp(0.15, 0.85);
    if (onTarget) _inc(stats, att.id).shotsOnTarget++;

    moments.add(
      MatchMoment(
        minute: minute,
        teamId: team.id,
        type: onTarget ? MomentType.shotOnTarget : MomentType.shotOffTarget,
        key: onTarget ? 'match_shot_on' : 'match_shot_off',
        args: {'att': att.name},
      ),
    );

    // goal?
    bool goal = false;
    if (onTarget) {
      final gkSaveBonus =
          0.0025 *
          (_skill(gkOpponent, 'gk_reflexes') +
              _skill(gkOpponent, 'gk_diving') -
              100);
      final goalProb = (xg - gkSaveBonus).clamp(0.03, 0.75);
      if (_rng.nextDouble() < goalProb) {
        goal = true;
        _inc(stats, att.id).goals++;
        // 40% chance to credit an assist

        _inc(stats, att.id).spEarned += 3;
        if (_rng.nextDouble() < 0.4) {
          _inc(stats, maybeAssist.id).assists++;
          _inc(stats, maybeAssist.id).spEarned += 2;
        }
        moments.add(
          MatchMoment(
            minute: minute,
            teamId: team.id,
            type: MomentType.goal,
            key: 'match_goal_basic',
            args: {
              'scorer': att.name,
              'assist': maybeAssist.name,
              'xg': xg.toStringAsFixed(2),
            },
          ),
        );
      } else {
        moments.add(
          MatchMoment(
            minute: minute,
            teamId: opponent.id,
            type: MomentType.save,
            key: 'match_save',
            args: {'gk': gkOpponent.name},
          ),
        );
      }
    }

    return _AttackResult(moments, goal);
  }

  // --------- ratings & weights ----------

  double _attackRating(Team t) {
    // average of top 6 attackers (role bias) + form - fatigue
    final players = [...t.squad]
      ..sort((a, b) => _attackerWeight(b).compareTo(_attackerWeight(a)));
    final top = players.take(min(6, players.length)).toList();
    final avg =
        top.map((p) => _attackComposite(p)).fold<double>(0, (a, b) => a + b) /
        max(1, top.length);
    final teamForm = t.morale * 10; // 0..10
    return avg + teamForm;
  }

  double _defenseRating(Team t) {
    final players = [...t.squad]
      ..sort((a, b) => _defenderWeight(b).compareTo(_defenderWeight(a)));
    final top = players.take(min(6, players.length)).toList();
    final avg =
        top.map((p) => _defenseComposite(p)).fold<double>(0, (a, b) => a + b) /
        max(1, top.length);
    return avg;
  }

  double _attackComposite(Player p) {
    final s =
        (_skill(p, 'finishing') * 0.35 +
        _skill(p, 'dribbling') * 0.15 +
        _skill(p, 'short_passing') * 0.15 +
        _skill(p, 'vision') * 0.15 +
        _skill(p, 'positioning') * 0.10 +
        _skill(p, 'composure') * 0.10);
    return _applyState(s, p);
  }

  double _defenseComposite(Player p) {
    final s =
        (_skill(p, 'tackling') * 0.30 +
        _skill(p, 'marking') * 0.25 +
        _skill(p, 'interceptions') * 0.25 +
        _skill(p, 'strength') * 0.10 +
        _skill(p, 'aggression') * 0.10);
    return _applyState(s, p);
  }

  double _offensiveScore(Player att, Player ast) {
    final s =
        (_skill(att, 'finishing') * 0.40 +
        _skill(att, 'dribbling') * 0.20 +
        _skill(att, 'positioning') * 0.15 +
        _skill(ast, 'short_passing') * 0.15 +
        _skill(ast, 'vision') * 0.10);
    return _applyState(s, att);
  }

  double _defensiveScore(Player def, Player gk) {
    final sDef =
        (_skill(def, 'tackling') * 0.35 +
        _skill(def, 'marking') * 0.35 +
        _skill(def, 'interceptions') * 0.20 +
        _skill(def, 'strength') * 0.10);
    final sGk = (_skill(gk, 'gk_diving') + _skill(gk, 'gk_reflexes')) / 2;
    return 0.7 * _applyState(sDef, def) + 0.3 * _applyState(sGk, gk);
  }

  double _applyState(double base, Player p) {
    final form = (p.form).clamp(0.4, 1.2); // 0.4..1.2
    final fatigue = (1.0 - p.fatigue).clamp(
      0.6,
      1.1,
    ); // more fatigue -> lower value
    return base * (0.5 + 0.5 * form) * (0.7 + 0.3 * fatigue);
  }

  // Weights for picks
  double _attackerWeight(Player p) {
    final roleBias = p.role.name.toLowerCase().contains('striker')
        ? 1.25
        : p.role.name.toLowerCase().contains('wing')
        ? 1.15
        : 1.0;
    return roleBias * (_attackComposite(p) + 1);
  }

  double _assistantWeight(Player p) {
    final roleBias = p.role.name.toLowerCase().contains('mid') ? 1.2 : 1.0;
    return roleBias *
        (_skill(p, 'short_passing') + _skill(p, 'vision') + 0.001);
  }

  double _defenderWeight(Player p) {
    final roleBias = p.role.name.toLowerCase().contains('cb') ? 1.25 : 1.0;
    return roleBias * (_defenseComposite(p) + 1);
  }

  double _disciplineWeight(Player p) {
    // more aggressive players show up more often
    return 0.5 + _skill(p, 'aggression') / 100.0;
  }

  // Utils
  T _weightedPick<T>(List<T> list, double Function(T) weight) {
    double sum = 0;
    for (final x in list) sum += max(0.0001, weight(x));
    var r = _rng.nextDouble() * sum;
    for (final x in list) {
      r -= max(0.0001, weight(x));
      if (r <= 0) return x;
    }
    return list.last;
  }

  double _skill(Player p, String id) => (p.skills[id]?.level ?? 50).toDouble();

  Player _fallbackGK(Team t) {
    // choose the best "defensive" player as emergency GK
    return _weightedPick(t.squad, (p) => _defenseComposite(p));
  }

  PlayerStats _inc(Map<String, PlayerStats> stats, String id) {
    return stats.putIfAbsent(id, () => PlayerStats());
  }
}

---
class _AttackResult {
  final List<MatchMoment> moments;
  final bool goal;

  _AttackResult(this.moments, this.goal);
}
---
// FILE: lib/features/match/ui/match_moments_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

import '../../../app/providers/providers.dart';
import '../models/match_moment.dart';

---
class MatchMomentsScreen extends ConsumerWidget {
  const MatchMomentsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final s = ref.watch(gameControllerProvider);
    final moments = s.lastMatchMoments;

    return Scaffold(
      appBar: AppBar(title: const Text('Moments')), // swap to l10n when you add the key
      body: moments.isEmpty
          ? Center(child: Text(l10n.noFixturesScheduled)) // simple placeholder
          : buildMoments(moments),
    );
  }
}

/// Simple list for match moments (debug-friendly; plain EN text)
ListView buildMoments(List<MatchMoment> moments) {
  return ListView.separated(
    itemCount: moments.length,
    separatorBuilder: (_, __) => const Divider(height: 1),
    itemBuilder: (_, i) {
      final m = moments[i];
      String text;
      switch (m.type) {
        case MomentType.kickOff:
          text = "Kick-off ${m.args['home']} vs ${m.args['away']}";
          break;
        case MomentType.halfTime:
          text = "Half-time";
          break;
        case MomentType.fullTime:
          text = "Full-time";
          break;
        case MomentType.buildUp:
          text = "Build-up";
          break;
        case MomentType.chance:
          text = "Chance: ${m.args['att']} (xG ${m.args['xg']})";
          break;
        case MomentType.shotOnTarget:
          text = "Shot on target by ${m.args['att']}";
          break;
        case MomentType.shotOffTarget:
          text = "Shot off target by ${m.args['att']}";
          break;
        case MomentType.save:
          text = "Save by ${m.args['gk']}";
          break;
        case MomentType.goal:
          final ast = m.args['assist'];
          text = (ast == null || (ast is String && ast.isEmpty))
              ? "GOAL! ${m.args['scorer']}"
              : "GOAL! ${m.args['scorer']} (ast ${m.args['assist']})";
          break;
        case MomentType.foul:
          text = "Foul";
          break;
        case MomentType.yellow:
          text = "Yellow: ${m.args['player']}";
          break;
        case MomentType.red:
          text = "Red: ${m.args['player']}";
          break;
        case MomentType.injury:
          text = "Injury";
          break;
      }
      return ListTile(
        leading: Text("${m.minute}'"),
        title: Text(text),
        subtitle: Text(m.key), // handy for i18n debugging
      );
    },
  );
}
---
// FILE: lib/features/match/ui/match_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

import '../../../app/providers/providers.dart';
import '../../../domain/models/fixture.dart';
import 'match_moments_screen.dart'; // NEW

---
class MatchScreen extends ConsumerWidget {
  const MatchScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final s = ref.watch(gameControllerProvider);

    final fixtures = s.fixtures;
    if (fixtures.isEmpty) {
      return Scaffold(
        appBar: AppBar(title: Text(l10n.matches)),
        body: Center(child: Text(l10n.noFixturesScheduled)),
      );
    }

    return Scaffold(
      appBar: AppBar(title: Text(l10n.matches)),
      body: ListView.separated(
        padding: const EdgeInsets.symmetric(vertical: 8),
        itemCount: fixtures.length,
        separatorBuilder: (_, __) => const SizedBox(height: 6),
        itemBuilder: (context, i) {
          final f = fixtures[i];
          final isCurrent = f.week == s.week;
          final played = f.played;

          // show "Moments" for current week's fixture once it's played and we have moments stored
          final hasMoments = played && isCurrent && s.lastMatchMoments.isNotEmpty;

          return Card(
            margin: const EdgeInsets.symmetric(horizontal: 12),
            child: ListTile(
              leading: _WeekBadge(week: f.week, highlight: isCurrent && !played),
              title: Text('${f.homeTeam} vs ${f.awayTeam}'),
              subtitle: played
                  ? _ResultTag(hg: f.homeGoals, ag: f.awayGoals)
                  : isCurrent
                  ? Text(l10n.thisWeeksMatch)
                  : null,
              trailing: (!played && isCurrent)
                  ? Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  OutlinedButton(
                    onPressed: () {
                      ref.read(gameControllerProvider.notifier).playMatch();
                    },
                    child: Text(l10n.play),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () async {
                      await ref.read(gameControllerProvider.notifier).advanceWeek();
                    },
                    child: Text(l10n.playAdvance),
                  ),
                ],
              )
                  : (hasMoments
                  ? TextButton(
                onPressed: () {
                  Navigator.of(context).push(
                    MaterialPageRoute(builder: (_) => const MatchMomentsScreen()),
                  );
                },
                child: const Text('Moments'), // swap to l10n when you add the key
              )
                  : null),
            ),
          );
        },
      ),
    );
  }
}

---
class _WeekBadge extends StatelessWidget {
  final int week;
  final bool highlight;
  const _WeekBadge({required this.week, required this.highlight});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    final bg = highlight
        ? Theme.of(context).colorScheme.primaryContainer
        : Theme.of(context).colorScheme.surfaceVariant;
    final fg = highlight
        ? Theme.of(context).colorScheme.onPrimaryContainer
        : Theme.of(context).colorScheme.onSurfaceVariant;

    return Container(
      width: 46,
      height: 46,
      alignment: Alignment.center,
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        l10n.wWeek(week),
        style: TextStyle(color: fg, fontWeight: FontWeight.w600),
      ),
    );
  }
}

---
class _ResultTag extends StatelessWidget {
  final int? hg;
  final int? ag;
  const _ResultTag({required this.hg, required this.ag});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final has = (hg != null && ag != null);
    final text = has ? l10n.resultScore(hg!, ag!) : l10n.resultPending;
    return Text(text);
  }
}
---
// FILE: lib/features/profile/ui/profile_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:footy_star/core/l10n/app_localizations.dart';
import '../../../app/providers/providers.dart';
import '../../contracts/ui/contract_screen.dart';

---
class ProfileScreen extends ConsumerWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.watch(gameControllerProvider);
    final controller = ref.read(gameControllerProvider.notifier);

    // Assuming first player is "me"
    final me = state.myTeam.squad.first;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.profile)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // Player Card
          _ProfileCard(
            name: me.name,
            age: me.age,
            ovr: me.ovr,
            reputation: me.reputation,
            form: me.form,
          ),

          const SizedBox(height: 16),

          // Coach Relationship
          _RelationshipCard(
            title: l10n.coachTrust,
            value: controller.coachTrust,
            status: controller.coachStatus,
            icon: Icons.sports,
          ),

          const SizedBox(height: 12),

          // Agent Relationship
          _RelationshipCard(
            title: l10n.agentRelationship,
            value: 0.65, // placeholder
            status: l10n.good,
            icon: Icons.handshake,
          ),

          const SizedBox(height: 16),

          // Actions Section
          Text(l10n.actions, style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),

          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              FilledButton.icon(
                onPressed: () => controller.askForRaise(),
                icon: const Icon(Icons.trending_up),
                label: Text(l10n.requestSalaryRaise),
              ),
              OutlinedButton.icon(
                onPressed: () => controller.requestTransfer(),
                icon: const Icon(Icons.flight_takeoff),
                label: Text(l10n.requestTransfer),
              ),
              OutlinedButton.icon(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => const ContractScreen()),
                  );
                },
                icon: const Icon(Icons.description),
                label: Text(l10n.viewContract),
              ),
            ],
          ),

          const SizedBox(height: 16),

          // Stats Overview
          Text(l10n.careerStats, style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),

          Row(
            children: [
              Expanded(child: _StatCard(label: l10n.matches, value: '${state.history.length}')),
              const SizedBox(width: 8),
              Expanded(child: _StatCard(label: l10n.goals, value: '0')), // TODO: track
              const SizedBox(width: 8),
              Expanded(child: _StatCard(label: l10n.assists, value: '0')), // TODO: track
            ],
          ),
        ],
      ),
    );
  }
}

---
class _ProfileCard extends StatelessWidget {
  final String name;
  final int age;
  final int ovr;
  final double reputation;
  final double form;

  const _ProfileCard({
    required this.name,
    required this.age,
    required this.ovr,
    required this.reputation,
    required this.form,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            CircleAvatar(
              radius: 40,
              backgroundColor: Theme.of(context).colorScheme.primary,
              child: Text(
                ovr.toString(),
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onPrimary,
                ),
              ),
            ),
            const SizedBox(height: 12),
            Text(
              name,
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            Text(
              l10n.ageAge(age),
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 12),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _Badge(label: l10n.form, value: '${(form * 100).round()}%'),
                _Badge(label: l10n.rep, value: reputation.toStringAsFixed(1)),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

---
class _RelationshipCard extends StatelessWidget {
  final String title;
  final double value;
  final String status;
  final IconData icon;

  const _RelationshipCard({
    required this.title,
    required this.value,
    required this.status,
    required this.icon,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            Icon(icon, size: 32),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(title, style: Theme.of(context).textTheme.titleSmall),
                  const SizedBox(height: 4),
                  LinearProgressIndicator(
                    value: value,
                    minHeight: 8,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    l10n.statusPercent(status, (value * 100).round()),
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

---
class _StatCard extends StatelessWidget {
  final String label;
  final String value;

  const _StatCard({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceVariant,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Text(
            value,
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 4),
          Text(
            label,
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
    );
  }
}

---
class _Badge extends StatelessWidget {
  final String label;
  final String value;

  const _Badge({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(value, style: Theme.of(context).textTheme.titleMedium),
        Text(label, style: Theme.of(context).textTheme.bodySmall),
      ],
    );
  }
}
---
// FILE: lib/features/settings/ui/settings_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:footy_star/core/l10n/app_localizations.dart';
import 'package:footy_star/main.dart'; // localeProvider

---
class SettingsScreen extends ConsumerStatefulWidget {
  const SettingsScreen({super.key});

  @override
  ConsumerState<SettingsScreen> createState() => _SettingsScreenState();
}

---
class _SettingsScreenState extends ConsumerState<SettingsScreen> {
  late String _localeCode;

  @override
  void initState() {
    super.initState();
    final current = ref.read(localeProvider);
    _localeCode = (current ?? const Locale('en')).languageCode;
  }

  void _changeLocale(String? value) {
    if (value == null) return;
    setState(() => _localeCode = value);
    ref.read(localeProvider.notifier).state = Locale(value);
    final l10n = AppLocalizations.of(context)!;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(l10n.languageChanged)),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.settings)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          Text(l10n.language, style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),
          DropdownButtonFormField<String>(
            value: _localeCode,
            items: [
              DropdownMenuItem(value: 'en', child: Text(l10n.english)),
              DropdownMenuItem(value: 'pt', child: Text(l10n.portuguese)),
            ],
            onChanged: _changeLocale,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              labelText: l10n.selectLanguage,
            ),
          ),
          const SizedBox(height: 24),
          ListTile(
            contentPadding: EdgeInsets.zero,
            title: Text(l10n.preview),
            subtitle: Text(l10n.previewSubtitle),
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              ElevatedButton(onPressed: () {}, child: Text(l10n.train)),
              OutlinedButton(onPressed: () {}, child: Text(l10n.restAllSquad)),
              FilledButton(onPressed: () {}, child: Text(l10n.casinoAllIn)),
            ],
          ),
        ],
      ),
    );
  }
}
---
// FILE: lib/features/skills/ui/skills_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../app/providers/providers.dart';
import '../../../domain/models/skill.dart';
import '../../../core/l10n/app_localizations.dart';

---
class SkillsScreen extends ConsumerWidget {
  const SkillsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.watch(gameControllerProvider);
    final controller = ref.read(gameControllerProvider.notifier);

    // Get player skills
    final player = state.myTeam.squad.first;
    final skills = player.skills;

    // Group skills by category
    final physicalSkills = skills.values.where((s) => s.category == SkillCategory.physical).toList();
    final technicalSkills = skills.values.where((s) => s.category == SkillCategory.technical).toList();
    final mentalSkills = skills.values.where((s) => s.category == SkillCategory.mental).toList();

    // Count skills ready to promote
    final readyToPromote = skills.values.where((s) => s.queuedLevels > 0).length;

    return DefaultTabController(
      length: 3,
      child: Scaffold(
        appBar: AppBar(
          title: Text(l10n.skills),
          bottom: TabBar(
            tabs: [
              Tab(text: l10n.physical),
              Tab(text: l10n.technical),
              Tab(text: l10n.mental),
            ],
          ),
          actions: [
            if (readyToPromote > 0)
              Padding(
                padding: const EdgeInsets.only(right: 8),
                child: Center(
                  child: FilledButton(
                    onPressed: () => _showPromoteAllDialog(context, ref),
                    child: Text('Promote All ($readyToPromote)'),
                  ),
                ),
              ),
          ],
        ),
        body: Column(
          children: [
            // SP Bar
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surfaceVariant,
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Skill Points (SP)',
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.primary,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      '${player.sp} SP',
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.onPrimary,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ],
              ),
            ),

            // Skills tabs
            Expanded(
              child: TabBarView(
                children: [
                  _SkillsList(skills: physicalSkills),
                  _SkillsList(skills: technicalSkills),
                  _SkillsList(skills: mentalSkills),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _showPromoteAllDialog(BuildContext context, WidgetRef ref) {
    final state = ref.read(gameControllerProvider);
    final player = state.myTeam.squad.first;

    // Calculate total cost
    int totalCost = 0;
    final skillsToPromote = player.skills.values.where((s) => s.queuedLevels > 0).toList();
    for (final skill in skillsToPromote) {
      totalCost += skill.totalPromotionCost;
    }

    final canAfford = state.economy.cash >= totalCost;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Promote All Skills'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('${skillsToPromote.length} skills ready to promote'),
            const SizedBox(height: 8),
            Text(
              'Total Cost: \$$totalCost',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            Text(
              'Current Cash: \$${state.economy.cash}',
              style: TextStyle(
                color: canAfford ? Colors.green : Colors.red,
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(AppLocalizations.of(context)!.cancel),
          ),
          FilledButton(
            onPressed: canAfford
                ? () {
              ref.read(gameControllerProvider.notifier).promoteAllSkills();
              Navigator.pop(context);
            }
                : null,
            child: const Text('Promote All'),
          ),
        ],
      ),
    );
  }
}

---
class _SkillsList extends ConsumerWidget {
  final List<Skill> skills;
  const _SkillsList({required this.skills});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: skills.length,
      itemBuilder: (context, index) {
        final skill = skills[index];
        return _SkillCard(skill: skill);
      },
    );
  }
}

---
class _SkillCard extends ConsumerWidget {
  final Skill skill;
  const _SkillCard({required this.skill});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.read(gameControllerProvider);

    final hasQueuedLevels = skill.queuedLevels > 0;
    final promotionCost = skill.promotionCost(skill.level);
    final canAfford = state.economy.cash >= promotionCost;

    // --- NOVO: calcula progresso e label consoante queued ---
    final cap = skill.xpCapForLevel(skill.level);
    final progressValue = hasQueuedLevels
        ? 1.0
        : (cap > 0 ? (skill.currentXp / cap).clamp(0.0, 1.0) : 0.0);

    final xpText = hasQueuedLevels
        ? 'Ready to promote'
        : l10n.xpProgress(skill.currentXp, cap);
    // --------------------------------------------------------

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Text(
                    skill.getLocalizedName(context),
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ),
                Row(
                  children: [
                    Text(
                      l10n.lvLevel(skill.level),
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    if (hasQueuedLevels) ...[
                      const SizedBox(width: 8),
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.primary,
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Text(
                          '+${skill.queuedLevels}',
                          style: TextStyle(
                            color: Theme.of(context).colorScheme.onPrimary,
                            fontSize: 12,
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
              ],
            ),
            const SizedBox(height: 8),
            ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: LinearProgressIndicator(
                // --- NOVO: barra fica 100% quando queued ---
                value: progressValue,
                minHeight: 8,
                backgroundColor: Theme.of(context).colorScheme.surfaceVariant,
              ),
            ),
            const SizedBox(height: 4),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  // --- NOVO: texto muda para "Ready to promote" quando queued ---
                  xpText,
                  style: Theme.of(context).textTheme.bodySmall,
                ),
                if (hasQueuedLevels)
                  FilledButton.tonal(
                    onPressed: canAfford
                        ? () {
                      ref.read(gameControllerProvider.notifier).promoteSkill(skill.id);
                    }
                        : null,
                    child: Text('Promote (\$$promotionCost)'),
                  ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
---
// FILE: lib/features/squad/ui/squad_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';
import '../../../app/providers/providers.dart';

---
class SquadScreen extends ConsumerWidget {
  const SquadScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final s = ref.watch(gameControllerProvider);

    return Scaffold(
      appBar: AppBar(title: Text(l10n.squad)),
      body: ListView.separated(
        padding: const EdgeInsets.all(16),
        itemCount: s.myTeam.squad.length,
        separatorBuilder: (_, __) => const Divider(),
        itemBuilder: (_, i) {
          final p = s.myTeam.squad[i];
          return ListTile(
            title: Text('${p.name} — ${l10n.ovr} ${p.ovr}'),
            subtitle: Text(
              '${l10n.form} ${(p.form * 100).round()}% • '
                  '${l10n.fatigue} ${(p.fatigue * 100).round()}% • '
                  '${l10n.rep} ${p.reputation.toStringAsFixed(1)}',
            ),
            trailing: const Icon(Icons.chevron_right),
          );
        },
      ),
    );
  }
}
---
// FILE: lib/features/standings/ui/national_standings_screen.dart
import 'package:flutter/material.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

---
class NationalStandingsScreen extends StatelessWidget {
  const NationalStandingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.nationalStandings)),
      body: Center(
        child: Text(l10n.nationalRankingsPlaceholder),
      ),
    );
  }
}
---
// FILE: lib/features/standings/ui/player_standings_screen.dart
import 'package:flutter/material.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

---
class PlayersStandingsScreen extends StatelessWidget {
  const PlayersStandingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.playersStandings)),
      body: DefaultTabController(
        length: 3,
        child: Column(
          children: [
            TabBar(
              tabs: [
                Tab(text: l10n.goals),
                Tab(text: l10n.assists),
                Tab(text: l10n.ratings),
              ],
            ),
            Expanded(
              child: TabBarView(
                children: [
                  Center(child: Text(l10n.topScorers)),
                  Center(child: Text(l10n.topAssists)),
                  Center(child: Text(l10n.bestRatings)),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
---
// FILE: lib/features/standings/ui/standings_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';
import '../../../app/providers/providers.dart';

---
class StandingsScreen extends ConsumerWidget {
  const StandingsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final s = ref.watch(gameControllerProvider);
    final rows = s.table.sorted();

    return Scaffold(
      appBar: AppBar(title: Text(l10n.standings)),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: rows.isEmpty
            ? Center(child: Text(l10n.noStandingsYet))
            : SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: DataTable(
            columns: [
              DataColumn(label: Text(l10n.positionShort)), // "#"
              DataColumn(label: Text(l10n.team)),
              DataColumn(label: Text(l10n.playedShort)), // "P"
              DataColumn(label: Text(l10n.winsShort)),   // "W"
              DataColumn(label: Text(l10n.drawsShort)),  // "D"
              DataColumn(label: Text(l10n.lossesShort)), // "L"
              DataColumn(label: Text(l10n.goalsForShort)), // "GF"
              DataColumn(label: Text(l10n.goalsAgainstShort)), // "GA"
              DataColumn(label: Text(l10n.goalDifferenceShort)), // "GD"
              DataColumn(label: Text(l10n.pointsShort)), // "Pts"
            ],
            rows: [
              for (int i = 0; i < rows.length; i++)
                DataRow(
                  cells: [
                    DataCell(Text('${i + 1}')),
                    DataCell(Text(rows[i].team)),
                    DataCell(Text('${rows[i].played}')),
                    DataCell(Text('${rows[i].won}')),
                    DataCell(Text('${rows[i].drawn}')),
                    DataCell(Text('${rows[i].lost}')),
                    DataCell(Text('${rows[i].gf}')),
                    DataCell(Text('${rows[i].ga}')),
                    DataCell(Text('${rows[i].gd}')),
                    DataCell(Text('${rows[i].points}')),
                  ],
                ),
            ],
          ),
        ),
      ),
    );
  }
}
---
// FILE: lib/features/stats/ui/stats_screen.dart
import 'package:flutter/material.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

---
class StatsScreen extends StatelessWidget {
  const StatsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.careerStats)),
      body: Center(
        child: Text(l10n.careerStatistics),
      ),
    );
  }
}
---
// FILE: lib/features/store/ui/store_hub_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

---
class StoreHubScreen extends ConsumerWidget {
  const StoreHubScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.store)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _StoreSection(
            title: l10n.realMoneyPurchases,
            subtitle: l10n.cashPacksAndPremium,
            icon: Icons.payment,
            onTap: () {
              // Navigate to IAP screen
            },
          ),
          const SizedBox(height: 8),
          _StoreSection(
            title: l10n.hourlyRewards,
            subtitle: l10n.claimFreeRewards,
            icon: Icons.timer,
            onTap: () {
              // Navigate to rewards screen
            },
          ),
        ],
      ),
    );
  }
}

---
class _StoreSection extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final VoidCallback onTap;

  const _StoreSection({
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: ListTile(
        leading: Icon(icon, size: 32),
        title: Text(title),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
      ),
    );
  }
}
---
// FILE: lib/features/training/ui/training_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../app/controllers/game_controller.dart';
import '../../../core/l10n/app_localizations.dart';
import '../../../app/providers/providers.dart';
import '../../../domain/models/player.dart';
import '../../../domain/models/skill.dart';

---
class TrainingScreen extends ConsumerWidget {
  const TrainingScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.watch(gameControllerProvider);
    final controller = ref.read(gameControllerProvider.notifier);

    // Assuming first player is "me"
    final me = state.myTeam.squad.first;

    // Group skills by category for display
    final physicalSkills = me.skills.values
        .where((s) => s.category == SkillCategory.physical)
        .toList();
    final technicalSkills = me.skills.values
        .where((s) => s.category == SkillCategory.technical)
        .toList();
    final mentalSkills = me.skills.values
        .where((s) => s.category == SkillCategory.mental)
        .toList();

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.myTraining),
        actions: [
          // SP indicator
          Container(
            margin: const EdgeInsets.only(right: 16),
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.primary,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Center(
              child: Text(
                '${me.sp} SP',
                style: TextStyle(
                  color: Theme.of(context).colorScheme.onPrimary,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _ProfileCard(me: me),
          const SizedBox(height: 16),

          // Physical Skills
          _SkillCategorySection(
            title: l10n.physical,
            skills: physicalSkills,
            player: me,
            controller: controller,
          ),
          const SizedBox(height: 16),

          // Technical Skills
          _SkillCategorySection(
            title: l10n.technical,
            skills: technicalSkills,
            player: me,
            controller: controller,
          ),
          const SizedBox(height: 16),

          // Mental Skills
          _SkillCategorySection(
            title: l10n.mental,
            skills: mentalSkills,
            player: me,
            controller: controller,
          ),
          const SizedBox(height: 16),

          // Recovery Section
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.recovery,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 12),
                  FilledButton.icon(
                    onPressed: () {
                      controller.recoverSelf();
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text(l10n.recoverySession)),
                      );
                    },
                    icon: const Icon(Icons.health_and_safety),
                    label: Text(l10n.recoverySession),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

---
class _ProfileCard extends StatelessWidget {
  final Player me;
  const _ProfileCard({required this.me});

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  me.name,
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                  decoration: BoxDecoration(
                    color: Theme.of(context).colorScheme.primaryContainer,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '${l10n.ovr} ${me.ovr}',
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.onPrimaryContainer,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: _StatBar(
                    label: l10n.form,
                    value: me.form,
                    color: Colors.green,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: _StatBar(
                    label: l10n.fatigue,
                    value: me.fatigue,
                    color: Colors.orange,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                _Badge(
                  text: '${l10n.rep}: ${me.reputation.round()}',
                  icon: Icons.star,
                ),
                const SizedBox(width: 8),
                _Badge(
                  text: '${l10n.consistency}: ${me.consistency.round()}',
                  icon: Icons.timeline,
                ),
                const SizedBox(width: 8),
                _Badge(
                  text: '${l10n.determination}: ${me.determination.round()}',
                  icon: Icons.military_tech,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

---
class _SkillCategorySection extends StatelessWidget {
  final String title;
  final List<Skill> skills;
  final Player player;
  final GameController controller;

  const _SkillCategorySection({
    required this.title,
    required this.skills,
    required this.player,
    required this.controller,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 12),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: skills
                  .map((skill) => _SkillChip(
                skill: skill,
                player: player,
                onTap: () {
                  controller.selfTrain(skill.id);
                },
              ))
                  .toList(),
            ),
          ],
        ),
      ),
    );
  }
}

---
class _SkillChip extends StatelessWidget {
  final Skill skill;
  final Player player;
  final VoidCallback onTap;

  const _SkillChip({
    required this.skill,
    required this.player,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final hasQueuedLevels = skill.queuedLevels > 0;

    return ActionChip(
      backgroundColor: hasQueuedLevels
          ? Theme.of(context).colorScheme.primaryContainer
          : null,
      label: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(skill.getLocalizedName(context)),
          const SizedBox(width: 4),
          Text(
            '${skill.level}',
            style: const TextStyle(fontWeight: FontWeight.bold),
          ),
          if (hasQueuedLevels) ...[
            const SizedBox(width: 4),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primary,
                borderRadius: BorderRadius.circular(4),
              ),
              child: Text(
                '+${skill.queuedLevels}',
                style: TextStyle(
                  fontSize: 10,
                  color: Theme.of(context).colorScheme.onPrimary,
                ),
              ),
            ),
          ],
        ],
      ),
      onPressed: onTap,
    );
  }
}

---
class _StatBar extends StatelessWidget {
  final String label;
  final double value;
  final Color color;

  const _StatBar({
    required this.label,
    required this.value,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              label,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            Text(
              '${(value * 100).round()}%',
              style: Theme.of(context).textTheme.bodySmall,
            ),
          ],
        ),
        const SizedBox(height: 4),
        ClipRRect(
          borderRadius: BorderRadius.circular(4),
          child: LinearProgressIndicator(
            value: value,
            minHeight: 6,
            backgroundColor: color.withOpacity(0.2),
            valueColor: AlwaysStoppedAnimation<Color>(color),
          ),
        ),
      ],
    );
  }
}

---
class _Badge extends StatelessWidget {
  final String text;
  final IconData icon;

  const _Badge({required this.text, required this.icon});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceVariant,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 12),
          const SizedBox(width: 4),
          Text(
            text,
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
    );
  }
}

---
// FILE: lib/features/transfers/ui/transfers_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:footy_star/core/l10n/app_localizations.dart';

---
class TransfersScreen extends ConsumerWidget {
  const TransfersScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      appBar: AppBar(title: Text(l10n.inboundTransfers)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _TransferOfferCard(
            club: 'Real Madrid',
            salary: 50000,
            role: l10n.roleStarter,
            duration: 3,
          ),
          _TransferOfferCard(
            club: 'Manchester City',
            salary: 45000,
            role: l10n.roleRotation,
            duration: 2,
          ),
        ],
      ),
    );
  }
}

---
class _TransferOfferCard extends StatelessWidget {
  final String club;
  final int salary;
  final String role;
  final int duration;

  const _TransferOfferCard({
    required this.club,
    required this.salary,
    required this.role,
    required this.duration,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  club,
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                Container(
                  padding:
                  const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: Theme.of(context).colorScheme.primaryContainer,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(l10n.newOffer),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                _OfferDetail(
                    label: l10n.salary, value: '\$$salary/${l10n.weekly}'),
                const SizedBox(width: 16),
                _OfferDetail(label: l10n.role, value: role),
                const SizedBox(width: 16),
                _OfferDetail(
                    label: l10n.duration,
                    value: '$duration ${l10n.years}'),
              ],
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () {},
                    child: Text(l10n.reject),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: FilledButton(
                    onPressed: () {},
                    child: Text(l10n.negotiate),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

---
class _OfferDetail extends StatelessWidget {
  final String label;
  final String value;

  const _OfferDetail({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: Theme.of(context).textTheme.bodySmall),
        Text(value, style: Theme.of(context).textTheme.bodyLarge),
      ],
    );
  }
}
---
// FILE: lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'core/theme/app_theme.dart';
import 'routes/shell_tabs.dart';
import 'core/l10n/app_localizations.dart';
import 'core/l10n/l10n_singleton.dart'; // adiciona isto

// Controls current app locale (null = system)
final localeProvider = StateProvider<Locale?>((_) => null);

void main() => runApp(const ProviderScope(child: MyApp()));

---
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final locale = ref.watch(localeProvider);

    return MaterialApp(
      title: 'Footy Star',
      theme: AppTheme.light(),
      darkTheme: AppTheme.dark(),
      themeMode: ThemeMode.light,
      locale: locale,
      localizationsDelegates: const [
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [Locale('en'), Locale('pt')],
      // builder to update the singleton
      builder: (context, child) {
        final l10n = AppLocalizations.of(context);
        if (l10n != null) {
          L10n.set(l10n);
        }
        return child ?? const SizedBox.shrink();
      },
      home: const ShellTabs(),
    );
  }
}
---
// FILE: lib/messages/casino_messages.dart
import 'package:footy_star/core/l10n/l10n_singleton.dart';

---
class CasinoMessages {
  static String win(int delta, int cash) =>
      L10n.i.casinoWin(delta.toDouble(), cash.toDouble());

  static String loss(int loss, int cash) =>
      L10n.i.casinoLoss(loss.toDouble(), cash.toDouble());
}
---
// FILE: lib/messages/economy_messages.dart
import 'package:footy_star/core/l10n/l10n_singleton.dart';

---
class EconomyMessages {
  static String weekSummary(int earned, int spent, int delta, int cash) =>
      L10n.i.weekSummary(earned, spent, delta, cash);
}
---
// FILE: lib/messages/general_messages.dart
import 'package:footy_star/core/l10n/l10n_singleton.dart';

---
class GeneralMessages {
  static String weekEnded(int week) => L10n.i.weekEnded(week);

  static String newSeason(int season) => L10n.i.newSeason(season);

  static String genericInfo(String text) => text; // livre, não precisa i18n
}
---
// FILE: lib/messages/match_messages.dart
import 'package:footy_star/core/l10n/l10n_singleton.dart';

---
class MatchMessages {
  static String result(int week, String home, int hg, String away, int ag) =>
      L10n.i.matchResult(week, home, hg, ag, away);

  static String friendly(String home, String away) =>
      L10n.i.matchPlayedFriendly(home, away);
}
---
// FILE: lib/messages/skill_messages.dart
import 'package:footy_star/core/l10n/l10n_singleton.dart';

---
class SkillMessages {
  static String trained(String player, String skill, int level) =>
      L10n.i.skillTrained(player, skill, level);

  static String squadRested() => L10n.i.squadRested;
}
---
// FILE: lib/routes/shell_tabs.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../core/theme/icons.dart';
import '../features/home/ui/home_screen.dart';
import '../features/skills/ui/skills_screen.dart';
import '../features/finance/ui/finance_hub_screen.dart';
import '../features/general/ui/general_hub_screen.dart';
import '../features/finance/ui/economy_screen.dart';
import '../features/store/ui/store_hub_screen.dart';
import '../features/settings/ui/settings_screen.dart';
import '../core/l10n/app_localizations.dart';

---
class ShellTabs extends ConsumerStatefulWidget {
  const ShellTabs({super.key});
  @override
  ConsumerState<ShellTabs> createState() => _ShellTabsState();
}

---
class _ShellTabsState extends ConsumerState<ShellTabs> {
  int _idx = 0;

  static const _pages = <Widget>[
    HomeScreen(),
    SkillsScreen(),
    FinanceHubScreen(),
    GeneralHubScreen(),
    EconomyScreen(),
    StoreHubScreen(),
    SettingsScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    final destinations = <NavigationDestination>[
      NavigationDestination(icon: const Icon(AppIcons.home), label: l10n.home),
      NavigationDestination(icon: const Icon(AppIcons.skills), label: l10n.skills),
      NavigationDestination(icon: const Icon(AppIcons.finance), label: l10n.finance),
      NavigationDestination(icon: const Icon(AppIcons.general), label: l10n.general),
      NavigationDestination(icon: const Icon(AppIcons.economy), label: l10n.economy),
      NavigationDestination(icon: const Icon(AppIcons.store), label: l10n.store),
      NavigationDestination(icon: const Icon(AppIcons.settings), label: l10n.settings),
    ];

    return Scaffold(
      body: _pages[_idx],
      bottomNavigationBar: NavigationBar(
        selectedIndex: _idx,
        onDestinationSelected: (i) => setState(() => _idx = i),
        destinations: destinations,
      ),
    );
  }
}